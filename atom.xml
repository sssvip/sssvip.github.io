<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  
  <subtitle>全世界太大，不断去追寻。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dxscx.com/"/>
  <updated>2019-10-08T02:31:09.801Z</updated>
  <id>https://blog.dxscx.com/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT 6828 lab1-01细读</title>
    <link href="https://blog.dxscx.com/2019/10/08/mit6828/lab1-1/"/>
    <id>https://blog.dxscx.com/2019/10/08/mit6828/lab1-1/</id>
    <published>2019-10-07T16:00:00.000Z</published>
    <updated>2019-10-08T02:31:09.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程-MIT-6-828-OS"><a href="#课程-MIT-6-828-OS" class="headerlink" title="课程 MIT 6.828 OS"></a>课程 MIT 6.828 OS</h1><p><a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html" target="_blank" rel="noopener">课程计划表地址</a></p><p>很久以前尝试过学堂在线清华的os课程，Lab1、Lab2确实也存在一定难度😀。</p><h3 id="为什么记录"><a href="#为什么记录" class="headerlink" title="为什么记录"></a>为什么记录</h3><blockquote><p>方便自己严谨的看待每一句话，每一行代码，进行详细分析以及加深理解及记忆，而不是遇到困难直接快速跳过，尝试补齐欠缺知识。</p></blockquote><p>不懂的时候以及理解不深刻的时候可以:</p><ol><li>尝试梳理这里有什么前置知识</li><li>记录查找前置知识的过程</li><li>记录阅读了哪些前置知识</li></ol><p>随心及阅读轨迹思考轨迹记录，尽可能的还原学习路线，帮助自己理解及回顾，<strong>如果</strong>能帮助到其他人就是更好的结果了，还有就是尽可能把Lecture读薄。</p><h1 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1: Booting a PC"></a>Lab 1: Booting a PC</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>专注3个部分，围绕三个目标学习更有效率：</p><ol><li>熟悉X86汇编、QEMU模拟器、PC加电启动程序</li><li>测验boot文件夹中的bootloader</li><li>深入研究kernel文件中kernel初始化模板</li></ol><a id="more"></a><h4 id="Software-Setup"><a href="#Software-Setup" class="headerlink" title="#Software Setup"></a>#Software Setup</h4><blockquote><p><strong>前置知识</strong> <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html" target="_blank" rel="noopener">GIT</a></p></blockquote><blockquote><p>如果觉得上面的GIT手册看起来过于专业（后面可当做手册查询），可以重点看下廖雪峰老师的git教程 对于初学和在这个试验用重点看下<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008" target="_blank" rel="noopener">时光机穿梭</a>，本身不难，只要把它看做是方便自己管理文件版本的工具就行。</p></blockquote><p>对于校外学习这门课程的同学来说，如果不会git学习到add commit diff几个能日常用到能回查改变就行了,完全会更好。</p><h4 id="Hand-In-Procedure"><a href="#Hand-In-Procedure" class="headerlink" title="#Hand-In Procedure"></a>#Hand-In Procedure</h4><p>给mit的同学们说明怎么提交代码、提交作业等等，对校外同学来说不是特重要，当然其中的make grade可以尝试使用，自动化评测当前实验的分数，目前这里用得到。</p><h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><p>第一个练习的目的是熟悉X86汇编和PC启动程序，尝试使用QEMU/GDB调试，带着自己的理解随便看😀以及准备回答后面的问题。</p><h4 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="#Getting Started with x86 assembly"></a>#Getting Started with x86 assembly</h4><blockquote><p><strong>前置知识</strong> <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">汇编 pcasm-book</a></p></blockquote><blockquote><p>如果觉得上面的汇编pdf不便于初次看,作为快速入门可以参看<a href="https://www.tutorialspoint.com/assembly_programming/" target="_blank" rel="noopener">Assembly Programming Tutorial</a>,但他们都是NASM风格的，但却别都不大哈，文中也提到去看NASM和GUN会汇编的区别<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan’s Guide to Inline Assembly</a>。</p></blockquote><p>后面提到对于x86汇编最佳参考资料肯定是Intel官方的<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm" target="_blank" rel="noopener">80386 Programmer’s Reference Manual</a>,在看这门课之前我下载过<a href="https://css.csail.mit.edu/6.858/2014/readings/i386.pdf" target="_blank" rel="noopener">PDF</a>进行阅读,还是觉得这里给出的html版本方便阅读一些。</p><blockquote><p>练习1: 熟悉汇编语言，暂时不用阅读他们，当你用的时候可能会查其中的一些资料。</p></blockquote><p><strong>练习1尝试:</strong></p><p>练习1应该暂时不用急着尝试😀，继续一路向西…</p><h4 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="#Simulating the x86"></a>#Simulating the x86</h4><p>本实验使用<a href="http://www.qemu.org/" target="_blank" rel="noopener">QEMU Emulator</a>作为模拟器，与真机PC来开发调试相比它能更快速的开机启动和减小调测的整个过程的时间，比如不用刻盘或写进U盘插入真机和开关机，这些步骤虽然都不能少，但都进行了模拟化操作，简单快捷。<br>还要一个好处是可以和<a href="http://www.gnu.org/software/gdb/" target="_blank" rel="noopener">GDB</a>结合调试，设置断点在真机上调测也不是件容易的事情，但让QEMU和GDB联调就方便了OS开发和调测。</p><p>在lab1源码根文件夹下打开terminal执行make qemu就能看到效果，可以关闭窗口也可以输入ctrl+a x结束程序。</p><h4 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="#The PC’s Physical Address Space"></a>#The PC’s Physical Address Space</h4><p>再多深入一点了解PC启动细节，一个PC的物理地址空间布局如下图：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- <span class="number">0xFFFFFFFF</span> (<span class="number">4</span>GB)</span><br><span class="line">|      <span class="number">32</span>-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0x00100000</span> (<span class="number">1</span>MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- <span class="number">0x000F0000</span> (<span class="number">960</span>KB)</span><br><span class="line">|  <span class="number">16</span>-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0x000C0000</span> (<span class="number">768</span>KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- <span class="number">0x000A0000</span> (<span class="number">640</span>KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure></p><p>第一批基于16位Intel8088处理器的PC机只能寻址1MB的物理内存。早期的PC物理地址从0x00000000到0x000FFFFF结束而不是0xFFFFFFFF结束。<br>早期的PC唯一能使用的随机访问内存RAM是标记<code>Low Memory</code>的640KB内的内存区域，事实上，更早的PC只能配置16kb、32kb、64kb RAM.</p><p>从0x000A0000到0x000FFFFF的384kb内存区域被保留以供显示输出其它作用。最重要的部分Basic Input/Output System (BIOS)内存区域在0x000F0000到0x000FFFFF的64kb区域。<br>以前的设备保存在ROM中(只读),现在保存在可更新的闪存中。BIOS做一些初始化和校验内存数量等等的校验工作，然后从软盘、硬盘、CD甚至是网络中加载操作系统并移交控制权。</p><h4 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="#The ROM BIOS"></a>#The ROM BIOS</h4><p>用QEMU调试32位机启动。</p><p>打开一个terminal 输入make qemu-nox-gdb 再打开一个terminal输入make gdb</p><p>你将看到这一行的<code>[f000:fff0] 0xffff0:    ljmp   $0xf000,$0xe05b</code>出现，这是由gdb反编译出的汇编指令，总结几点：</p><ol><li>和上面的内存布局图所表示的那样，bios起点地址为0xffff0</li><li>PC从 CS = 0xf000 and IP = 0xfff0开始执行</li><li>第一条指令是jmp指令，将要跳转到段地址CS = 0xf000 and IP = 0xe05b去执行指令</li></ol><p>当设备一旦重启或加电(模拟器就是启动程序),处理器进入实模式，会设置CS寄存器为0xf000和IP寄存器为0xffff0,结合起来最终意义下一次执行代码地址为<br>0x000fffff0,CS寄存器会向左移一位（乘以16）加上IP寄存器的值，成为下一次执行指令的位置,<strong>前置知识</strong>学习汇编中会说明段寄存器和段偏移地址组合寻址地址。</p><blockquote><p>练习2: 用GDB的单步指令si 追踪BIOS的一些指令尝试猜测它们有什么作用。</p></blockquote><p>当BIOS运行，它设置了一个中断描述表以及初始化了一些像VGA显示等等的设备。后面初始胡PCI总线以及所有BIOS知道的重要的设备，然后在软盘、硬盘等启动设备上搜索启动文件，加载并移交控制权执行。</p><p><strong>练习2尝试:</strong></p><p>make gdb 后出现的是这行指令 <code>[f000:fff0]    0xffff0:    ljmp   $0x3630,$0xf000e05b</code></p><p>与文中<code>[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b</code>不一致，先暂时不管，往后单步运行分析试试，后面来查下原因(因为我直接运行是完全正确的，这里ljmp参数和文中不一致应该是理解不到位，估计是不影响流程的，后面详细看下),初步发现里面的有的绝对地址不同电脑不同版本的QEMU可能是不一致的，初步学习可以不用太过于关注，重点是熟悉单步调试，和观测BIOS执行流程。</p><p>连续运行几次si,也就是执行几条指令看看效果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>. [f000:e05b]    <span class="number">0xfe05b</span>:cmpw   $<span class="number">0xffc8</span>,%cs:(%esi)  <span class="comment">//第一条bios跳转过来，进行比较,比较原因暂时未知</span></span><br><span class="line"> <span class="number">2</span>. [f000:e062]    <span class="number">0xfe062</span>:jne    <span class="number">0xd241d416</span>  <span class="comment">//上一条指令如果不等进行跳转</span></span><br><span class="line"> <span class="number">3</span>. [f000:e066]    <span class="number">0xfe066</span>:xor    %edx,%edx  <span class="comment">//从左侧连续地址看出上一句没有跳转，说明上上句相等， 当前句edx进行清0</span></span><br><span class="line"> <span class="number">4</span>. [f000:e068]    <span class="number">0xfe068</span>:mov    %edx,%ss  <span class="comment">//清零栈寄存器</span></span><br><span class="line"> <span class="number">5</span>. [f000:e06a]    <span class="number">0xfe06a</span>:mov    $<span class="number">0x7000</span>,%sp <span class="comment">//sp设置0x7000</span></span><br><span class="line"> <span class="number">6</span>. [f000:e070]    <span class="number">0xfe070</span>:mov    $<span class="number">0x2d4e</span>,%dx <span class="comment">//设置dx 0x2d4e</span></span><br><span class="line"> <span class="number">7</span>. [f000:e076]    <span class="number">0xfe076</span>:jmp    <span class="number">0x5575ff02</span>  <span class="comment">//跳转</span></span><br><span class="line"> <span class="number">8</span>. [f000:ff00]    <span class="number">0xfff00</span>:cli   <span class="comment">//关闭中断指令，上面一句怎么就跳转到0xfff00来了不清楚，不应该转到5575ff02?</span></span><br><span class="line"> <span class="number">9</span>. [f000:ff01]    <span class="number">0xfff01</span>:cld   <span class="comment">//字符串方向标识，可查手册</span></span><br><span class="line"><span class="number">11</span>. [f000:ff02]    <span class="number">0xfff02</span>:mov    %ax,%cx  <span class="comment">//ax-&gt;cx 赋值</span></span><br><span class="line"><span class="number">12</span>. [f000:ff05]    <span class="number">0xfff05</span>:mov    $<span class="number">0x8f</span>,%ax <span class="comment">// 0x8f-&gt;ax</span></span><br><span class="line"><span class="number">13</span>. [f000:ff0b]    <span class="number">0xfff0b</span>:out    %al,$<span class="number">0x70</span> <span class="comment">// out用到端口,将ax的低8位值写入端口0x70</span></span><br><span class="line"><span class="comment">//查到 070 CMOS RAM/RTC (Real Time Clock  MC146818),说明这里和时钟是相关的</span></span><br><span class="line"><span class="number">14</span>. [f000:ff0d]    <span class="number">0xfff0d</span>:in     $<span class="number">0x71</span>,%al <span class="comment">//读取0x71到al</span></span><br><span class="line"><span class="comment">//查询到071端口 CMOS RAM data port (ISA, EISA),里面存储了时间相关的值</span></span><br><span class="line"><span class="number">15</span>. [f000:ff0f]    <span class="number">0xfff0f</span>:in     $<span class="number">0x92</span>,%al <span class="comment">//读取0x92到al</span></span><br><span class="line"><span class="comment">//查询到92端口PS/2 system control port A  (port B is at 0061)，系统控制相关的端口</span></span><br><span class="line"><span class="number">16</span>. [f000:ff11]    <span class="number">0xfff11</span>:or     $<span class="number">0x2</span>,%al <span class="comment">//0x2换成二进制00000010</span></span><br><span class="line"><span class="comment">//0x2 or al 相当于一定保证al中右边第二位一定为1 也就是al-&gt; xxxxxx1x 字母x是al中原值</span></span><br><span class="line"><span class="number">17</span>. [f000:ff13]    <span class="number">0xfff13</span>:out    %al,$<span class="number">0x92</span> <span class="comment">//回写al到92端口</span></span><br><span class="line"><span class="number">18</span>. [f000:ff15]    <span class="number">0xfff15</span>:mov    %cx,%ax <span class="comment">//cx-&gt;ax 还原ax的值，上面保存过</span></span><br><span class="line"><span class="number">19</span>. [f000:ff18]    <span class="number">0xfff18</span>:lidtl  %cs:(%esi) <span class="comment">//加载中断向量寄存器  但怎么不是lidtw? </span></span><br><span class="line"><span class="comment">//可以一步一步看BIOS到底干了什么，后面不再分析...个人觉得如果和其它人的绝对地址和指令有一定差异不用太担心</span></span><br><span class="line"><span class="comment">//毕竟你们环境不一致可能存在部分不同，因为不同版本，模拟器实现可能存在差异，不用太在意，先读薄。</span></span><br></pre></td></tr></table></figure></p><p>分析BIOS过程额外参考资料:</p><blockquote><p><a href="http://bochs.sourceforge.net/techspec/PORTS.LST" target="_blank" rel="noopener">端口查询参考</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/fatsheep9146/p/5078179.html" target="_blank" rel="noopener">详细的学习笔记参考</a></p></blockquote><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>软盘和硬盘被分为一个个512字节大小的区域，叫做扇区，扇区是最小传输单元，每次读写操作只能是以扇区为单位读取或写入一个或多个扇区的数据。如果磁盘是启动盘(<strong>前置知识</strong>:启动盘的区分,在第一个扇区510字节有标识是启动盘的magic number，0x55aa，这里不讨论大小端问题)<br>，那么第一个扇区就被叫做启动扇区。BIOS就会加载这启动扇区的数据到内存0x7c00处，也就是结束地址是0x7dff,共计512字节。然后用jmp指令设置CS:IP到0000:07c00,相当于移交了控制权到启动扇区的代码，虽然是武断的硬编码加载到0x7c00,但这是固定的和通用做法，所以没什么问题。</p><p>6.828使用传统的方式将bootloader装在512字节中，bootloader有boot文件夹中boot.S和main.c组成，仔细阅读他们，以清楚的知道他们到底干了什么，它至少要执行以下两个主要功能:</p><ol><li>从16位实模式切换到32位保护模式，因为保护模式可以寻址1MB以上的内存地址，保护模式的描述可以在<a href="https://pdos.csail.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">PC Assembly Language</a>中1.27和1.28查看，但这里你只需要知道在保护模式下段基址:段偏移在实模式下和保护模式下的不同就行，在保护模式下段偏移是32位而不是16位(也就是说段偏移地址范围从0xffff扩大到了0xffffffff)。</li><li>bootloader从硬盘上通过x86的特殊IO指令控制集成电路磁盘设备寄存器直接读取内核。如果你想了解清楚是哪些特殊的IO指令，可以翻阅<a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">the 6.828 reference page</a>的<code>IDE hard drive controller</code>一节查询，目前不用了解太多关于IO指令的细节，尽管他是开发一个操作系统非常重要的部分，从概念和体系结构来看，他们比较无趣(复杂、难😀)。</li></ol><p>当你理解了bootloader的源码后，看看文件<code>obj/boot/boot.asm</code>，它是被GNUmakefile指引make执行编译后反编译bootloader得到的文件。反编译文件可以容易看到bootloader在内存中的指令，方便用GDB跟踪以及单步调试。同样的，<code>obj/kern/kernel.asm</code>是JOS内核的反编译文件，也可以方便的对JOS的内核进行调试。</p><p>你可以用<code>b</code>指令设置断点，例如<code>b *0x7c00</code>在0x7c00处设置一个断点，设置断点后，你可以用<code>c</code>或者<code>si</code>继续执行，<code>c</code>命令是continue缩写，意味着它会执行到下一个断点停下来，<code>si</code>指令则是单步运行，为<code>step instruction</code>的缩写，可以用<code>si N</code>一次运行N条指令。</p><p>为了查看在内存中下一条将被执行的指令，可以使用<code>x/i</code>，使用语法为<code>x/Ni ADDR</code>，意思是查看地址<code>ADDR</code>出<code>N</code>条指令情况。</p><p><a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html" target="_blank" rel="noopener">练习3实验工具资料 lab tools guide</a></p><blockquote><p>练习3: 查看实验工具资料lab tools guide,尤其那些GDB命令部分，即使你熟悉GDB,那里面也可能包含很多你不知道的对操作系统开发有用的命令。</p></blockquote><blockquote><p>在bootloader加载处<code>0x7c00</code>处设置一个断点，用<code>c</code>继续运行然后停在0x7c00,用反编译文件obj/boot/boot.asm跟踪boot/boot.S，也可以用<code>x/i</code>命令进行查看指令序列与反编译文件obj/boot/boot.asm进行对比。</p></blockquote><blockquote><p>跟踪boot/main.c中方法<code>bootmain()</code>，然后跟进<code>readsect</code>，然后精准识别<code>readsect</code>中每一条语句对应的汇编指令，跟踪完<code>readsect</code>剩余代码最后返回到<code>bootmain()</code>,然后搞清楚<code>for</code>循环的开始和结束中每一个从硬盘读取内核扇区的操作，再找到循环结束后会执行什么代码，在那设置一个断点，然后执行用<code>c</code>继续执行到那停下，然后单步运行bootloder剩余的部分。</p></blockquote><p>连续文字版的<code>练习3</code>不方便直接按步骤阅读和执行，尝试进行精简拆解成工作流：</p><ol><li>熟悉GDB tool (这是必须的，不过对于练习3也不难,个人觉得可以暂缓，因为后面明确说明了指令)</li><li>一个terminal执行<code>make qemu-nox-gdb</code> 另一个terminal执行<code>make gdb</code>(后面的操作都在这个调试terminal进行)</li><li>输入<code>b *0x7c00</code>,然后输入<code>c</code>继续运行  (提示:每个输入都进行一次回车,虽然像废话，怕有的初学者以为是连续输入)</li><li>输入<code>x/50i 0x7c00</code>,这里会输出50条后面将要执行的指令,可以对比着obj/boot/boot.asm看，应该是基本一致的代码。</li><li>在boot.asm中查看bootmain()的地址，然后用<code>b</code>指令进行断点，然后尝试单步运行起来，尝试跟踪到readsect</li><li>单步运行readsect地址后的指令，尽可能到搞清楚指令和readsect函数中的语句的对应关系(这里能深刻认识c语句与汇编的转化，看得到一些底层实现)</li><li>找到for的起止点，查看循环内读取扇区的操作</li><li>最后找到for结束点,设置断点，<code>c</code>指令会连续运行到那，单步指令走详细查看直到bootloader结束。</li></ol><p><strong>练习3尝试:</strong></p><p>对比boot.asm内容看</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">obj/boot/boot.out</span>:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00007c00 &lt;start&gt;:</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line"><span class="attribute">start:</span></span><br><span class="line">  .code16                     # Assemble for 16-bit mode</span><br><span class="line">  cli                         # Disable interrupts</span><br><span class="line">    <span class="attribute">7c00</span>:       fa                      cli    </span><br><span class="line">  cld                         # String operations increment</span><br><span class="line">    <span class="attribute">7c01</span>:       fc                      cld    </span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">    <span class="attribute">7c02</span>:       31 c0                   xor    %eax,%eax</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">    <span class="attribute">7c04</span>:       8e d8                   mov    %eax,%ds</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">    <span class="attribute">7c06</span>:       8e c0                   mov    %eax,%es</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line">    <span class="attribute">7c08</span>:       8e d0                   mov    %eax,%ss</span><br><span class="line"></span><br><span class="line">00007c0a &lt;seta20.1&gt;:</span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line"><span class="attribute">seta20.1:</span></span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">    <span class="attribute">7c0a</span>:       e4 64                   in     $0x64,%al</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">    <span class="attribute">7c0c</span>:       a8 02                   test   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line">    <span class="attribute">7c0e</span>:       75 fa                   jne    7c0a &lt;seta20.1&gt;</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">    <span class="attribute">7c10</span>:       b0 d1                   mov    $0xd1,%al</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line">篇幅受限省略一部分，可自己查看剩余部分...</span><br></pre></td></tr></table></figure><p>尝试到步骤4的结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">50</span>i <span class="number">0x7c00</span></span><br><span class="line">=&gt; <span class="number">0x7c00</span>:cli    <span class="comment">//和反编译指令及地址一致</span></span><br><span class="line">   <span class="number">0x7c01</span>:cld    <span class="comment">//一致</span></span><br><span class="line">   <span class="number">0x7c02</span>:<span class="keyword">xor</span>    %eax,%eax  <span class="comment">//可认为一致 xorw 变为了xor  清零 这里不影响</span></span><br><span class="line">   <span class="number">0x7c04</span>:mov    %eax,%ds   <span class="comment">//movw 变为mov 同样不影响</span></span><br><span class="line">   <span class="comment">//因为都会清零寄存器这里 movw只是清零32位而已.更干净😀 可以认为一致</span></span><br><span class="line">   <span class="number">0x7c06</span>:mov    %eax,%es   <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c08</span>:mov    %eax,%ss   <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c0a</span>:<span class="keyword">in</span>     $<span class="number">0x64</span>,%al  <span class="comment">//inb变为in同样道理不影响 可以认为一致</span></span><br><span class="line">   <span class="number">0x7c0c</span>:test   $<span class="number">0x2</span>,%al   <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c0e</span>:jne    <span class="number">0x7c0a</span>     <span class="comment">//这里将seta20.1换位了绝对地址 可以认为一致</span></span><br><span class="line">   <span class="number">0x7c10</span>:mov    $<span class="number">0xd1</span>,%al  <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c12</span>:<span class="keyword">out</span>    %al,$<span class="number">0x64</span>  <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c14</span>:<span class="keyword">in</span>     $<span class="number">0x64</span>,%al  <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c16</span>:test   $<span class="number">0x2</span>,%al   <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c18</span>:jne    <span class="number">0x7c14</span>     <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c1a</span>:mov    $<span class="number">0xdf</span>,%al  <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c1c</span>:<span class="keyword">out</span>    %al,$<span class="number">0x60</span>  <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c1e</span>:lgdtl  (%esi)     <span class="comment">//可以认为一致   lgdt    gdtdesc换为了这两句</span></span><br><span class="line">   <span class="number">0x7c21</span>:fs jl  <span class="number">0x7c33</span>     <span class="comment">//可以认为一致</span></span><br><span class="line">   <span class="number">0x7c24</span>:<span class="keyword">and</span>    %al,%al    <span class="comment">//movl    %cr0, %eax 换位 al求与</span></span><br><span class="line">   <span class="number">0x7c26</span>:<span class="keyword">or</span>     $<span class="number">0x1</span>,%ax   </span><br><span class="line">   <span class="number">0x7c2a</span>:mov    %eax,%cr0  <span class="comment">//一致</span></span><br><span class="line">   <span class="number">0x7c2d</span>:ljmp   $<span class="number">0xb866</span>,$<span class="number">0x87c32</span>  <span class="comment">//$PROT_MODE_CSEG, $protcseg换位了绝对地址</span></span><br><span class="line">   <span class="comment">//这里值得注意的是为什么反编译文件是7c32这里段偏移地址却成为了0x87c32</span></span><br><span class="line">   <span class="comment">//还有反编译中找不到PROT_MODE_CSEG的踪迹，PROT_MODE_CSEG 0xb866地址从哪来的</span></span><br><span class="line">   <span class="number">0x7c34</span>:adc    %al,(%eax) <span class="comment">//没找到此指令</span></span><br><span class="line">   后面不再比对细看，下面继续实验...</span><br></pre></td></tr></table></figure><p>继续尝试第5步，<code>b *0x7d15</code>,前四句push指令可以暂时不用管，这是编译器为保护调用栈以及保护数据的，与每个方法结束的pop对应,bootmain这里刚好特殊点这里没有返回所以你在后面也看不到成对的pop,不重要，暂时不用管。<br>开始关心bootmain的中c代码<code>struct Proghdr *ph, *eph;</code>申明变量，在汇编中局部体现不出来，这里暂时不用管。接下来看到几句push和call</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7d1a</span>:push   $<span class="number">0x0</span>  <span class="comment">//readseg第三个参数  offset</span></span><br><span class="line"><span class="number">0x7d1c</span>:push   $<span class="number">0x1000</span>  <span class="comment">//readseg第二个参数  count</span></span><br><span class="line"><span class="number">0x7d21</span>:push   $<span class="number">0x10000</span>  <span class="comment">//readseg第一个参数  pa</span></span><br><span class="line"><span class="number">0x7d26</span>:call   <span class="number">0x7cdc</span>  <span class="comment">//7cdc 你在boot.asm中搜索会发现就是readseg的地址</span></span><br><span class="line">这一句执行后也就意味着会进入readseg函数</span><br></pre></td></tr></table></figure><p>下面如练习要求所说，我们重点分析readseg函数c代码与汇编指令的大致关系</p><p>c代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">end_pa = pa + count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// round down to sector boundary</span></span><br><span class="line">pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line"><span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line"><span class="comment">// we load in increasing order.</span></span><br><span class="line"><span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line"><span class="comment">// Since we haven't enabled paging yet and we're using</span></span><br><span class="line"><span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line"><span class="comment">// use physical addresses directly.  This won't be the</span></span><br><span class="line"><span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">readsect((<span class="keyword">uint8_t</span>*) pa, offset);</span><br><span class="line">pa += SECTSIZE;</span><br><span class="line">offset++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>汇编代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i 0x7cdc</span><br><span class="line">   0x7cdc:push   %ebp   #保护堆栈及数据，暂时不管</span><br><span class="line">   0x7cdd:mov    %esp,%ebp  #保护堆栈及数据，暂时不管</span><br><span class="line">   0x7cdf:push   %edi  #保护堆栈及数据，暂时不管</span><br><span class="line">   0x7ce0:push   %esi  #保护堆栈及数据，暂时不管</span><br><span class="line">   0x7ce1:mov    0x10(%ebp),%edi  #这里将offset赋值到edi寄存器，这里想不清楚的话可以想一下mov %esp,%ebp</span><br><span class="line">   #此时的ebp应该是指向“当时”的栈顶，因为前面push 3个参数后又push %ebp占用4字节，所以要想取出第3个参数，</span><br><span class="line">   #必须取出此栈针指向的倒数第四个push的地方，</span><br><span class="line">   #所以偏移0x10=&gt;16字节 取出了当时push的0x0赋值给edi寄存器，后面的指令(0x7cfb处)能证明edi被当做offset来使用</span><br><span class="line">   0x7ce4:push   %ebx  #保护ebx值，因为后第二句要使用</span><br><span class="line">   0x7ce5:mov    0xc(%ebp),%esi  #这里将count赋值到esi寄存器    0xc=&gt;12   取出第二个参数 </span><br><span class="line">   0x7ce8:mov    0x8(%ebp),%ebx  #这里将pa赋值到ebx寄存器    0x8=&gt;8   取出第一个参数</span><br><span class="line">   0x7ceb:shr    $0x9,%edi  # edi也就是offset右移九位，暂时不清楚原因</span><br><span class="line">   0x7cee:add    %ebx,%esi</span><br><span class="line">   0x7cf0:inc    %edi  #offset++</span><br><span class="line">   0x7cf1:and    $0xfffffe00,%ebx</span><br><span class="line">   0x7cf7:cmp    %esi,%ebx  #while 判断条件</span><br><span class="line">   0x7cf9:jae    0x7d0d   # while 不满足结束跳转</span><br><span class="line">   0x7cfb:push   %edi  #readsect 函数第二个参数 offset  明显证明edi是offset</span><br><span class="line">   0x7cfc:push   %ebx  #readsect 函数第一个参数 pa</span><br><span class="line">   0x7cfd:inc    %edi  #offset++</span><br><span class="line">   0x7cfe:add    $0x200,%ebx  //pa+=SECTSIZE</span><br><span class="line">   0x7d04:call   0x7c7c  #调用readsect</span><br><span class="line">   0x7d09:pop    %eax  #这个的作用不是很理解,因为暂时没找到对应的push call里面跟踪了下，也没找到</span><br><span class="line">   0x7d0a:pop    %edx  #这个的作用不是很理解</span><br><span class="line">   0x7d0b:jmp    0x7cf7  # 继续while循环</span><br><span class="line">   0x7d0d:lea    -0xc(%ebp),%esp   # while结束后执行</span><br><span class="line">   0x7d10:pop    %ebx  #恢复堆栈及数据</span><br><span class="line">   0x7d11:pop    %esi  #恢复堆栈及数据</span><br><span class="line">   0x7d12:pop    %edi  #恢复堆栈及数据</span><br><span class="line">   0x7d13:pop    %ebp  #恢复堆栈及数据</span><br><span class="line">   0x7d14:ret    #返回bootmain</span><br></pre></td></tr></table></figure></p><p>练习第6步要求单步运行readsect后的指令，搞清楚他们的对应关系，所以可以<code>b *0x7c7c</code>然后<code>c</code>停下继续分析</p><p>这里结合这boot.asm中反编译内容waitdisk分析，因为waitdisk是readsect读写磁盘的必调用的子函数，有必要先看下，后面分析waitdisk直接带过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">waitdisk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// wait for disk reaady</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitdisk中又存在一个内联函数，这里从后面的反编译结果能看出来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint8_t</span></span><br><span class="line">inb(<span class="keyword">int</span> port)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> data;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"inb %w1,%0"</span> : <span class="string">"=a"</span> (data) : <span class="string">"d"</span> (port))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出来，waitdisk是一个不需要任何参数，仅仅是一个当条件不满足一直循环的函数而已，下面是它在boot.asm中被反编译的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">waitdisk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">7</span>c6a:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint8_t</span></span><br><span class="line">inb(<span class="keyword">int</span> port)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> data;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"inb %w1,%0"</span> : <span class="string">"=a"</span> (data) : <span class="string">"d"</span> (port))</span></span>;</span><br><span class="line">    <span class="number">7</span>c6b:       ba f7 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1f7</span>,%edx  </span><br><span class="line">    <span class="comment">//从上面的端口查询参考连接可以查到，0x1f7代表了status register,这里将其送入edx表明告知需要状态寄存器的内容</span></span><br><span class="line">    <span class="number">7</span>c70:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line">    <span class="comment">//这个虽然是常规保护栈操作，但这里不用深究，因为有asm volatile做底层处理，我们这里只是刚好看到了这三句对应的指令而已</span></span><br><span class="line">    7c72:       ec                      in     (%dx),%al </span><br><span class="line">    <span class="comment">//将状态寄存器的内容写进ax的第八位，因为状态寄存器本身也只有8位</span></span><br><span class="line">        <span class="comment">// wait for disk reaady</span></span><br><span class="line">        <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">    <span class="number">7</span>c73:       <span class="number">83</span> e0 c0                <span class="keyword">and</span>    $<span class="number">0xffffffc0</span>,%eax   <span class="comment">//这里0xffffffc0 其实也就是0xc0</span></span><br><span class="line">    <span class="comment">//0xc0-&gt;11000000   0x40-&gt;01000000 这里的结束条件意味着inb返回值一定要第8位为0，第7位为1</span></span><br><span class="line">    <span class="comment">//根据参考查询bit 7 = 1  controller is executing a command，bit 6 = 1  drive is ready</span></span><br><span class="line">    <span class="comment">//所以这里结束条件是设备状态就绪并且没有执行语句，这里分析符合预期</span></span><br><span class="line">    <span class="number">7</span>c76:       <span class="number">3</span>c <span class="number">40</span>                   cmp    $<span class="number">0x40</span>,%al  <span class="comment">//while结束判断(设备状态是否就绪)</span></span><br><span class="line">    <span class="number">7</span>c78:       <span class="number">75</span> f8                   jne    <span class="number">7</span>c72 &lt;waitdisk+<span class="number">0x8</span>&gt; <span class="comment">//不等继续循环</span></span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="number">7</span>c7a:       <span class="number">5</span>d                      pop    %ebp  <span class="comment">//恢复堆栈</span></span><br><span class="line">    <span class="number">7</span>c7b:       c3                      ret    <span class="comment">//waitdisk结束</span></span><br></pre></td></tr></table></figure><p>分析了readsect子函数，回到readsect方法的0x7c7c处继续分析，后面会发现还需要insl这个内联函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">insl(<span class="keyword">int</span> port, <span class="keyword">void</span> *addr, <span class="keyword">int</span> cnt)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"cld\n\trepne\n\tinsl"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     : <span class="string">"=D"</span> (addr), <span class="string">"=c"</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">                     : <span class="string">"d"</span> (port), <span class="string">"0"</span> (addr), <span class="string">"1"</span> (cnt)</span></span></span><br><span class="line"><span class="function"><span class="params">                     : <span class="string">"memory"</span>, <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/50i 0x7c7c</span><br><span class="line">=&gt; 0x7c7c:  push   %ebp #保护堆栈</span><br><span class="line">   0x7c7d:  mov    %esp,%ebp  #将堆栈信息存入ebp</span><br><span class="line">   0x7c7f:  push   %edi #保护edi</span><br><span class="line">   0x7c80:  mov    0xc(%ebp),%ecx  #将第二个readsect参数offset放入ecx(上面分析过为什么这里是第二个参数)</span><br><span class="line">   0x7c83:  call   0x7c6a #call waitdisk，等待设备就绪</span><br><span class="line">   0x7c88:  mov    $0x1,%al #</span><br><span class="line">   0x7c8a:  mov    $0x1f2,%edx</span><br><span class="line">   0x7c8f:  out    %al,(%dx)   #outb(0x1F2, 1);  端口含义:sector count 仅读取1个扇区</span><br><span class="line">   0x7c90:  mov    $0x1f3,%edx</span><br><span class="line">   0x7c95:  mov    %cl,%al</span><br><span class="line">   0x7c97:  out    %al,(%dx)   #outb(0x1F3, offset); 端口含义:sector number  offset控制哪一个扇区</span><br><span class="line">   0x7c98:  mov    %ecx,%eax   #将offset放入edx</span><br><span class="line">   0x7c9a:  mov    $0x1f4,%edx</span><br><span class="line">   0x7c9f:  shr    $0x8,%eax</span><br><span class="line">   0x7ca2:  out    %al,(%dx)   #outb(0x1F4, offset &gt;&gt; 8); 端口含义:cylinder low  </span><br><span class="line">   # 暂时不理解扇区位置和扇柱低位的关系，这里是16倍关系</span><br><span class="line">   0x7ca3:  mov    %ecx,%eax</span><br><span class="line">   0x7ca5:  mov    $0x1f5,%edx</span><br><span class="line">   0x7caa:  shr    $0x10,%eax</span><br><span class="line">   0x7cad:  out    %al,(%dx)   #outb(0x1F5, offset &gt;&gt; 16); 16==0x10(差点以为找不到对应)   端口含义:cylinder high   、</span><br><span class="line">   # 暂时不理解扇区位置和扇柱高位的关系，这里是32倍关系</span><br><span class="line">   0x7cae:  mov    %ecx,%eax</span><br><span class="line">   0x7cb0:  mov    $0x1f6,%edx</span><br><span class="line">   0x7cb5:  shr    $0x18,%eax</span><br><span class="line">   0x7cb8:  or     $0xffffffe0,%eax</span><br><span class="line">   0x7cbb:  out    %al,(%dx)   #outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);   端口含义:drive/head</span><br><span class="line">   #0xE0-&gt; 11100000  暂时不理解这里的右移</span><br><span class="line">   0x7cbc:  mov    $0x20,%al</span><br><span class="line">   0x7cbe:  mov    $0x1f7,%edx</span><br><span class="line">   0x7cc3:  out    %al,(%dx)   #outb(0x1F7, 0x20); 端口含义:status register</span><br><span class="line">   0x7cc4:  call   0x7c6a      #call waitdisk，等待设备就绪</span><br><span class="line">   0x7cc9:  mov    0x8(%ebp),%edi  #这里才取出将第一个readsect参数`*dst`</span><br><span class="line">   0x7ccc:  mov    $0x80,%ecx  #512/4 = 0x80 = 128</span><br><span class="line">   0x7cd1:  mov    $0x1f0,%edx #端口含义:data register</span><br><span class="line">   0x7cd6:  cld</span><br><span class="line">   0x7cd7:  repnz insl (%dx),%es:(%edi)   #// read a sector   insl(0x1F0, dst, SECTSIZE/4);</span><br><span class="line">   # 这里同样可以查端口参考手册，查出来0xf0-0xf71表示了读取扇区相关参数</span><br><span class="line">   0x7cd9:  pop    %edi</span><br><span class="line">   0x7cda:  pop    %ebp</span><br><span class="line">   0x7cdb:  ret</span><br></pre></td></tr></table></figure><p>不理解这里的全部我觉得对于初学者不重要，更重要的是怎么分析怎么查手册，对于初学使用来说，知道readsect是传入内存地址dst和扇区偏移offset就会读取offset扇区处一个扇区512字节内容到dst处内存中就够了，对于分析来说，知道这里面有等待磁盘操作，等待磁盘干了什么事？干了读取设备状态，怎么读取设备状态？这里读了0x1f7端口的内容判断了两bit的内容，标志没有命令执行和磁盘就绪就说明磁盘可操作。然后就是outb写入告知怎么样的磁盘操作，0x1f2-0x1f7写入相关需求，然后继续判断磁盘就绪情况，最后insl读取一个扇区内容到dst，过程大致就是如此，分析至此，先走流程读薄。</p><p>这里有点跳跃，但就像堆栈一样，这里分析了readseg后又要回到bootmain方法中了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTSIZE        512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELFHDR          ((struct Elf *) 0x10000) <span class="comment">// scratch space</span></span></span><br><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line">readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>根据之前的分析，这里可以知道，ELFHDR就是读取磁盘的起点,<code>SECTSIZE*8</code>代表读取读取4096字节，0代表偏移量0，这里为什么是读取4096字节，我们来算一算对不对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> e_magic;       <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">        <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> e_type;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_machine;</span><br><span class="line">        <span class="keyword">uint32_t</span> e_version;</span><br><span class="line">        <span class="keyword">uint32_t</span> e_entry;</span><br><span class="line">        <span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line">        <span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line">        <span class="keyword">uint32_t</span> e_flags;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line">        <span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>32*6 + 8*12 + 16*8</code> 怎么算都不等于4096，所以不清楚这里读取4096到0x10000的位置的用途，不过不影响后面分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// read 1st page off disk</span></span><br><span class="line">        readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// is this a valid ELF?</span></span><br><span class="line">        <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)  <span class="comment">//数据已经读取，判断此elf是否正确</span></span><br><span class="line">                <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">        ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);  <span class="comment">//program header </span></span><br><span class="line">        <span class="comment">//ELFHDR 基址+ ELFHDR中记录的program header offset偏移</span></span><br><span class="line">        eph = ph + ELFHDR-&gt;e_phnum;  </span><br><span class="line">        <span class="comment">//最后一个program header的地址</span></span><br><span class="line">        <span class="comment">//这里有点奇怪e_phnum按字面理解不应该是program header个数吗？这里按逻辑理解e_phnum应该是</span></span><br><span class="line">        <span class="comment">//e_phnum=sizeof(ph)*count</span></span><br><span class="line">        <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">                <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">                <span class="comment">// as the physical address)</span></span><br><span class="line">                readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">        <span class="comment">// note: does not return!</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();<span class="comment">//内核加载完毕，执行entry地址</span></span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">        outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面查看的是c,再具体看一看汇编执行情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/50i 0x7d15</span><br><span class="line">   0x7d15:  push   %ebp</span><br><span class="line">   0x7d16:  mov    %esp,%ebp</span><br><span class="line">=&gt; 0x7d18:  push   %esi</span><br><span class="line">   0x7d19:  push   %ebx</span><br><span class="line">   0x7d1a:  push   $0x0</span><br><span class="line">   0x7d1c:  push   $0x1000</span><br><span class="line">   0x7d21:  push   $0x10000</span><br><span class="line">   0x7d26:  call   0x7cdc   #前几句前面文中已经介绍过，这里call readseg</span><br><span class="line">   0x7d2b:  add    $0xc,%esp   #平栈 这里是esp +c 个人认为相当于pop 三次</span><br><span class="line">   0x7d2e:  cmpl   $0x464c457f,0x10000  # 比较魔数 0x10000及elf地址，这里本身也就是取elf struct首字段</span><br><span class="line">   0x7d38:  jne    0x7d71    # 非elf标准文件进入bad</span><br><span class="line">   0x7d3a:  mov    0x1001c,%eax  #ELFHDR + ELFHDR-&gt;e_phoff 同样能被编译器算出绝对地址 0x1001c</span><br><span class="line">   0x7d3f:  movzwl 0x1002c,%esi  #扩展到0x0001002c</span><br><span class="line">   0x7d46:  lea    0x10000(%eax),%ebx #此时ebx是多少  # ebx -&gt; ph</span><br><span class="line">   0x7d4c:  shl    $0x5,%esi  </span><br><span class="line">   0x7d4f:  add    %ebx,%esi  # esi -&gt; eph</span><br><span class="line">   0x7d51:  cmp    %esi,%ebx   #for 结束判断</span><br><span class="line">   0x7d53:  jae    0x7d6b   # 大于等于就call 读取readseg</span><br><span class="line">   0x7d55:  pushl  0x4(%ebx)   #ebx -&gt;ph</span><br><span class="line">   0x7d58:  pushl  0x14(%ebx)  </span><br><span class="line">   0x7d5b:  add    $0x20,%ebx</span><br><span class="line">   0x7d5e:  pushl  -0x14(%ebx)   #readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); push3个参数</span><br><span class="line">   0x7d61:  call   0x7cdc    #readseg</span><br><span class="line">   0x7d66:  add    $0xc,%esp  #call 后的平栈</span><br><span class="line">   0x7d69:  jmp    0x7d51   #继续for 判断</span><br><span class="line">   0x7d6b:  call   *0x10018  #for 结束后执行entry()，进入内核   </span><br><span class="line">   #因为elf绝对地址，所以这里也是被计算成绝对地址</span><br><span class="line">   #这里能看出来 0x18=24   24/4=6 也就是结构体第6个参数的地址 </span><br><span class="line">   #也就是变量e_entry的地址所以能看出来每个变量相当于一个指针占用4字节</span><br><span class="line">   0x7d71:  mov    $0x8a00,%edx   # bad</span><br><span class="line">   0x7d76:  mov    $0xffff8a00,%eax</span><br><span class="line">   0x7d7b:  out    %ax,(%dx)</span><br><span class="line">   0x7d7d:  mov    $0xffff8e00,%eax</span><br><span class="line">   0x7d82:  out    %ax,(%dx)</span><br><span class="line">   0x7d84:  jmp    0x7d84   #死循环</span><br></pre></td></tr></table></figure></p><p>接下来回答问题:</p><ol><li><p>处理器从哪一个点开始执行32位指令的？是什么导致从16位切换到32位的？</p><p> 从<code>.code32 protcseg</code>这里开始执行的。<br> <code>ljmp    $PROT_MODE_CSEG, $protcseg</code>此指令前的加载段描述等等前置操作以及此长跳转以及切换到了32位</p></li><li><p>bootloader最后一条指令是什么？内核加载后第一条指令是什么？</p><p> 最后一条指令是<code>0x7d6b:  call   *0x10018</code>，然后就再也没回到bootmain😀<br> 内核全部加载完后第一条指令也是<code>call *0x10018</code>，如果是elf加载后的话是check magic number</p></li><li><p>内核的第一条指令是什么？（仔细思考和<code>2</code>中的第二问有区别吗？）</p><p> 很多其它问题还可以从boot.asm中静态的找到答案，这里就不能在boot.asm中找了，毕竟call后就跳出bootmain以及bootloader了，<br>天真的以为在kernel.asm中能找到0x10018，然后并没有找到，这个时候可以在gdb中<code>b *0x10018</code>然后si就能回答当前问题了。</p><p> 最后从kern/kernel.asm 中entry找到第一条指令<code>movw    $0x1234,0x472</code></p><p> gdb断点数据如下:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007d69 in ?? ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x7d6b:  call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:  movw   $0x1234,0x472</span><br><span class="line">0x0010000c in ?? ()</span><br></pre></td></tr></table></figure></code></pre><p>   最后尝试出来了，开始理解错误了，不是call 0x10018就断点0x10018,而是应该断点这条call语句，然后成功了，si下一条语句能看出来跳转到了0x10000c,这里也看出来，以后如果想直接跳转到call的地址，只需要call addr+4就行了，这就是它的吓一跳语句地址，也能看出来走一点弯路也能收获到不一样的知识点。</p></li><li><p>bootloader怎么决定读取多少个内核扇区？在哪找到这些信息的？</p><p> 读取多少个扇区由<code>eph = ph + ELFHDR-&gt;e_phnum;</code>这句话决定了，这个信息由首次加载8个扇区<code>readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</code>信息到ELFHDR结构体得到的。</p></li></ol><h4 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="#Loading the Kernel"></a>#Loading the Kernel</h4><p>到目前为止已经2w多字了，可能大部分都是copy的代码吧😀，还是有点吓人<br>接下来我们关注更多在boot/main.c中的c语言细节，在开始之前，可以回顾一些c语言编程基本知识。</p><blockquote><p>练习4: 阅读c指针部分，最好的参考资料是K&amp;R的C编程语言,推荐在亚马逊购买,或者看mit的拷贝版。</p></blockquote><blockquote><p>阅读K&amp;R中5.1节指针和地址到5.5节字符指针和函数，然后下载pointers.c,运行并要清楚的知道它输出的每一个值。特别是，你要明确理解1到6行的指针位置，以及2到4行的值的原因，还有为什么第五行的值似乎很奇怪。</p></blockquote><blockquote><p>另一个C语言参考资料参考A tutorial by Ted Jensen</p></blockquote><blockquote><p>警告:除非你以及比较了解C，不然别跳过这一节，不然后面的实验相当的困难。</p></blockquote><p><a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&amp;s=books" target="_blank" rel="noopener">C编程语言</a>亚马逊地址</p><p><a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&amp;doc_library=MIT01&amp;doc_number=000355242&amp;year=&amp;volume=&amp;sub_library=" target="_blank" rel="noopener">C编程语言</a> MIT拷贝版</p><p><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c" target="_blank" rel="noopener">pointers.c</a></p><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf" target="_blank" rel="noopener">A tutorial by Ted Jensen</a></p><p><strong>练习4尝试:</strong><br>这里就简单理解下pointer.c,其余的要靠自己多看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">f(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//上面申明变量或初始化不用多说</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1: a = %p, b = %p, c = %p\n"</span>, a, b, c); <span class="comment">//输出指针地址也还好</span></span><br><span class="line"></span><br><span class="line">    c = a; <span class="comment">//c指针也指向a数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        a[i] = <span class="number">100</span> + i; <span class="comment">//对a数组进行组个赋值</span></span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>; <span class="comment">//改变c[0],这里也就改变了a[0],因为a和c地址执行的是同一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>, </span><br><span class="line">          a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//所以a[0]=c[0]=200,a[1]如期=101 a[2]如期=102 a[3]如期=103</span></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>; <span class="comment">//c[1]=a[1]=300</span></span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>; <span class="comment">//c+2代表c[2]   这里也就意味着是c[2]=301</span></span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>; <span class="comment">//3[c]是c[3]的另一种写法，罕见。c[3]=a[3]=302</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">     a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//a[0]=200  a[1]=300 a[2]=301 a[3]=302</span></span><br><span class="line">    c = c + <span class="number">1</span>;  <span class="comment">//c指针移位  间接说c指向了a[1]不再指向a或a[0]</span></span><br><span class="line">    *c = <span class="number">400</span>;  <span class="comment">//a[1]=400</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">     a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//a[0]=200 a[1]=400 a[2]=301 a[3]=302</span></span><br><span class="line">    <span class="comment">//记住在执行下面语句之前c目前指向了a[1]</span></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);  <span class="comment">//这里的重点在于优先级，先强转char*再加1</span></span><br><span class="line">    <span class="comment">//也就是在强转int *之前c仅仅向后移动了一个char的位置，因为+1是c的数据类型为char *,+1也就移动一个char位置</span></span><br><span class="line">    <span class="comment">//所以c目前的位置在a[1]+ 1 byte</span></span><br><span class="line">    *c = <span class="number">500</span>; <span class="comment">//改变c当前位置的值也就改变了当前a[1]+ 1 byte位置后4byte的数据为500</span></span><br><span class="line">    <span class="comment">//这里需要详细写出a[1] a[2]来以说明改变情况</span></span><br><span class="line">    <span class="comment">//a[1] a[2] 再执行`*c = 500`前的数据情况是  400 301</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00000000   int</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000001 10010000   400</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000001 00101101   301</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000001 11110100   500</span></span><br><span class="line">    <span class="comment">//(这里我是将十进制转16进制然后再8421编码出来得到，你也可以用在线转换工具进行转换)</span></span><br><span class="line">    <span class="comment">//执行`*c = 500`改变的是a[1]起第9bit到41bit之间的数据，500二进制表示00000000000000000000000111110100b</span></span><br><span class="line">    <span class="comment">//所以执行后a[1] a[2]的二进制表示是 00000000000000000000000000011111b 01000000000000000000000100101101</span></span><br><span class="line">    <span class="comment">//对不对后面执行对比下就知道</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n"</span>,</span><br><span class="line">     a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//预期结果 a[0]不变=200 a[1]=15  a[2]=41261 a[3]不变302  //这里暂时不对后面再回过头来看下</span></span><br><span class="line">    b = (<span class="keyword">int</span> *) a + <span class="number">1</span>; <span class="comment">//这个会移动4位 int</span></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) a + <span class="number">1</span>); <span class="comment">//这里会移动1位 char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6: a = %p, b = %p, c = %p\n"</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pointer.c的line 5输出分析还有点问题，认知看来还是不够，后面回过头来还会继续纠正的。</p><p>为了深入理解boot/main.c，你需要知道ELF二进制文件。当编译并链接一个C程序(如JOS内核)时，编译器将每个C源(‘. C ‘)文件转换成一个对象(‘.o’)文件，其中包含汇编语言指令，以硬件期望的二进制格式编码。然后连接器组合所有编译的文件到一个单二进制镜像比如obj/kern/kernel,本实验中就是ELF格式的二进制文件，全称是“可执行可连接格式”</p><p>详细的关于ELF格式可以查看<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">the ELF specification</a>,但在这个实验中你不用特别深入的了解这个格式。尽管整个格式十分的有用和复杂，最复杂的部分是支持动态加载和共享包，本实验中不涉及。<a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Wikipedia page</a>有简短的描述。</p><p>为了课程，你可以将elf可执行文件认为是一个加载信息的头文件，紧跟着几个程序段，他们是一些被加载到特定位置的数据和代码连续块，bootloader不修改任何代码和数据，仅仅是加载后执行它。</p><p>一个ELF二进制文件仅仅以一个固定长度的ELF头开端，紧跟这一个变长的程序头，列出了需要被加载的程序段。elf头定义在inc/elf.h中，我们感兴趣的程序段有:</p><ul><li>.text 程序的可执行指令</li><li>.rodata 只读数据，例如c编译器生成的ascii字段串常量（我们不用费心去设置不准硬件写入）</li><li>.data 数据段，程序的初始化的数据，例如声明的初始化了的全局变量 int x= 5;</li></ul><p>当连接器计算出程序的内存布局，它会保留未初始化的全局变量到.bss段，例如int x;它紧跟着.data段。c要求未初始化的数据赋默认值0。因此不需要存储.bss段的内容在elf二进制文件中，相反的，连接器只记录.bss段的大小和位置。bootloader或者程序本身需要分配0给.bss段。</p><p>检查输入<code>objdump -h obj/kern/kernel</code>命令后输出的关于内核可执行文件的名称，大小和连接地址。你会发现比我们上面列出的更多的段，但是那些段对于我们本实验不是特别重要，目前不用过多了解。其它更多的是存储了调试信息，通常情况下调试信息会包含在可执行程序中，但是不会被程序加载器加载(意味着是被调试器加载😀)。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">obj/kern/kernel</span>:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"><span class="attribute">Sections:</span></span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         000019e9  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006c0  f0101a00  00101a00  00002a00  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         00003b95  f01020c0  001020c0  000030c0  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001948  f0105c55  00105c55  00006c55  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0111300  00111300  00012300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000648  f0113060  00113060  00014060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002b  00000000  00000000  000146a8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure><p>特别注意一下，.text代码段的VMA连接地址和LMA加载地址，LMA的地址一段应该加载进内存（上文的00100000）。</p><p>bootloader利用ELF程序头决定怎么加载段数据，程序头指明了ELF对象哪些部分要加载近内存中，以及应该每个段应该加载的目标位置。你可以输入<code>objdump -x obj/kern/kernel</code>审查程序头，输出结果比刚刚输出要详细一些，这里就不再显示。</p><p>BIOS加载boot启动扇区到0x7c00.因此0x7c00也是启动扇区的加载地址，也是执行起始地址，也是连接地址。我们在boot/Makefrag通过-Ttext 0x7c00设置连接地址，因此连接器生成的文件可以产生正确的内存地址。</p><blockquote><p>练习5: 大概意思是更改bootloader的连接地址，然后尝试跟踪下bootloader指令，看看会发生什么。改回来后注意make clean。</p></blockquote><p>回过头来看内核的加载和连接地址，不像bootloader一样，两个地址不一样，内核个告诉bootload将其加载在地地址1M处，但它期望从一个高地址执行。我们将在下一节中深入研究如何实现这一点。</p><p>除了段信息，在ELF头中还有对我们来说很重要的信息e_entry,这个区域存有程序进入点的连接地址，程序代码段可开始执行的内存地址，你可以用<code>objdump -f obj/kern/kernel</code>看到进入点entry point</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start<span class="built_in"> address </span>0x0010000c</span><br></pre></td></tr></table></figure><p>您现在应该能够理解boot/main.c中最小的ELF加载器了，它从磁盘将内核的每一个段读的加载地址然后读取进内存，然后跳转到内核的进入点entry point执行(移交控制权)。</p><blockquote><p>练习6: 现在我们可以用GDB的<code>x</code>指令检查内存，GDB manual有更详细的介绍，但是现在，已经足够去知道命令<code>x/Nx ADDR</code>,它会在ADDR处输出<code>N</code>个字的内存指令<br>注意<code>x</code>用小写，警告:字的大小不是完全统一的，在GNU汇编中，一个字两个字节。</p></blockquote><p>重置机器(退出QEMU/GDB然后重启),检查BIOS进入bootloader处0x00100000地址8个字，然后再看bootloader进入内核的点。为什么他们不同？第二个断点是什么?(不用去调试，仅仅思考就行了。)<br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html" target="_blank" rel="noopener">GDB manual</a></p><p>练习6差不多前面我们也都涉及，这里就不在尝试了，继续往下。尽快进入lab2。</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>我们现在开始在最小内核JOS尝试深入一点更多细节。(后面你会写相同代码！)。比如bootloader，内核从一些汇编语言代码开始，这些代码设置了一些东西，以便C语言代码能够正确执行。</p><h4 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="#Using virtual memory to work around position dependence"></a>#Using virtual memory to work around position dependence</h4><p>当你查看bootloader的连接和加载地址，他们高度吻合，但是他们和内核的连接地址（objdump输出的）和加载地址有（相当大）差距。回去检查确保你知道这里在说什么（上面的对boot和kernel的objdump输出）。（连接内核比连接bootloader复杂很多，因此它的连接和加载地址都在kern/kernel.ld顶部）</p><p>操作系统内核通常被连接和执行在一个高的虚拟地址，比如0xf0100000,以便将处理器的低虚拟地址留给用户程序使用，这样分配的原因会在下一个实验变的更加清晰。</p><p>很多机器在0xf0100000处并没有物理地址，因此我们不能指望有能力将内核存储在那。相反我们将用处理器的内存管理硬件去映射虚拟地址0xf0100000(因为内核连接在这里，也期望从这里运行)到0x00100000(这里就是bootloader加载内核到物理内存的地址)。这个方式，尽管内核的虚拟地址已经足够高，可以为用户进程留下足够的地址空间。它将被加载到PC设备的物理内存1M处，仅仅在BIOS ROM上，这种方法要求pc最少有1M物理内存(这样0x00100000物理地址才能用)，但是几乎适用于1990年后生产的所有电脑。</p><p>事实上，在下一个实验，我们将映射整个底部256MB物理内存空间，从物理地址0x00000000到0x0fffffff,到虚拟地址0xf0000000到0xffffffff对应的。你现在应该知道为什么JOS仅仅只能使用开始的256MB物理内存。</p><p>就目前而言，我们仅仅映射前4MB物理内存，已经足够我们开始行动了。我们使用kern/entrypgdir.c中手工编写的静态初始化的页目录和页表来实现这一点。目前你不需要完全明白它们工作的细节，只用关心它们的效果就行了。直到kern/entry.S设置CR0_PG标志，内存引用都被认为是物理地址(严格来说，它们是线性地址，但是boot/boot.S设置了一个唯一的从线性地址到物理地址的映射，我们不再改变它)。一旦CR0_PG被设置，内存引用都是虚拟地址，由虚拟地址硬件转换为物理地址。entry_pgdir翻译从0xf0000000到0xf0400000虚拟地址到物理地址0x00000000到0x00400000,同样虚拟地址0x00000000到0x00400000也被映射到物理地址0x00000000到0x00400000.任何不在这两个范围内的虚拟地址都将导致硬件异常，因为我们目前都还没有设置中断处理，将会导致QEME存储机器状态并退出(如果你没有使用6.828补丁的QEMU可能会不断重启)</p><blockquote><p>练习7: 使用QEMU和GDB跟踪JOS内核在<code>movl %eax, %cr0</code>停下，检查在0x00100000和0xf0100000处的内存。现在使用<code>stepi</code>GDB单步指令然后继续检查0x00100000和0xf0100000出的内存。确保你理解发生了什么。</p></blockquote><p>在新映射建立之后，如果映射没有就位，第一个不能正常工作的指令是什么?在kern/entry.S中注释掉<code>movl %eax， %cr0</code>跟踪一下，看看你是不是对的。</p><p><strong>尝试练习7:</strong><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *<span class="number">0</span>x10000C</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x10000c</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be <span class="symbol">i386</span></span><br><span class="line"><span class="symbol"></span>=&gt; <span class="number">0</span>x10000<span class="symbol">c:</span>  movw   $<span class="number">0</span>x1234,<span class="number">0</span>x472</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0</span>x0010000c in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100015:</span>  mov    $<span class="number">0</span>x112000,%eax</span><br><span class="line"><span class="number">0</span>x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>x10001<span class="symbol">a:</span>  mov    %eax,%<span class="symbol">cr3</span></span><br><span class="line"><span class="symbol">0</span>x0010001a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>x10001<span class="symbol">d:</span>  mov    %<span class="symbol">cr0</span>,%eax</span><br><span class="line"><span class="number">0</span>x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100020:</span>  <span class="built_in">or</span>     $<span class="number">0</span>x80010001,%eax</span><br><span class="line"><span class="number">0</span>x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100025:</span>  mov    %eax,%<span class="symbol">cr0</span> #下一条单步运行设置内存映射</span><br><span class="line"><span class="number">0</span>x00100025 in ?? ()</span><br><span class="line">(gdb) x/<span class="number">4</span>xb <span class="number">0</span>x00100000</span><br><span class="line"><span class="number">0</span><span class="symbol">x100000:</span> <span class="number">0</span>x02  <span class="number">0</span>xb0  <span class="number">0</span>xad  <span class="number">0</span>x1b   </span><br><span class="line">(gdb) x/<span class="number">4</span>xb <span class="number">0</span>xf0100000</span><br><span class="line"><span class="number">0</span>xf0100000 &lt;_start+<span class="number">4026531828</span>&gt;<span class="symbol">:</span> <span class="number">0</span>x00  <span class="number">0</span>x00  <span class="number">0</span>x00  <span class="number">0</span>x00   #当前<span class="number">0</span>x00100000和<span class="number">0</span>xf0100000没有一致</span><br><span class="line">(gdb) si     #单步运行mov    %eax,%<span class="symbol">cr0</span></span><br><span class="line"><span class="symbol"></span>=&gt; <span class="number">0</span><span class="symbol">x100028:</span>  mov    $<span class="number">0</span>xf010002f,%eax</span><br><span class="line"><span class="number">0</span>x00100028 in ?? ()</span><br><span class="line">(gdb) x/<span class="number">4</span>xb <span class="number">0</span>x00100000</span><br><span class="line"><span class="number">0</span><span class="symbol">x100000:</span> <span class="number">0</span>x02  <span class="number">0</span>xb0  <span class="number">0</span>xad  <span class="number">0</span>x1b</span><br><span class="line">(gdb) x/<span class="number">4</span>xb <span class="number">0</span>xf0100000</span><br><span class="line"><span class="number">0</span>xf0100000 &lt;_start+<span class="number">4026531828</span>&gt;<span class="symbol">:</span> <span class="number">0</span>x02  <span class="number">0</span>xb0  <span class="number">0</span>xad  <span class="number">0</span>x1b  #当前<span class="number">0</span>x00100000和<span class="number">0</span>xf0100000一致</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>尝试注释掉entry.S文件中的%movl %eax, %cr0这句话，make clean,然后make运行</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *<span class="number">0</span>x10000C</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x10000c</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be <span class="symbol">i386</span></span><br><span class="line"><span class="symbol"></span>=&gt; <span class="number">0</span>x10000<span class="symbol">c:</span>  movw   $<span class="number">0</span>x1234,<span class="number">0</span>x472</span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0</span>x0010000c in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100015:</span>  mov    $<span class="number">0</span>x112000,%eax</span><br><span class="line"><span class="number">0</span>x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>x10001<span class="symbol">a:</span>  mov    %eax,%<span class="symbol">cr3</span></span><br><span class="line"><span class="symbol">0</span>x0010001a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>x10001<span class="symbol">d:</span>  mov    %<span class="symbol">cr0</span>,%eax</span><br><span class="line"><span class="number">0</span>x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100020:</span>  <span class="built_in">or</span>     $<span class="number">0</span>x80010001,%eax</span><br><span class="line"><span class="number">0</span>x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span><span class="symbol">x100025:</span>  mov    $<span class="number">0</span>xf010002c,%eax</span><br><span class="line"><span class="number">0</span>x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>x10002<span class="symbol">a:</span>  jmp    *%eax</span><br><span class="line"><span class="number">0</span>x0010002a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; <span class="number">0</span>xf010002c &lt;relocated&gt;<span class="symbol">:</span>  add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.<span class="symbol">S:74</span></span><br><span class="line"><span class="number">74</span>    movl  $<span class="number">0</span>x0,%ebp     # nuke frame pointer</span><br><span class="line">(gdb) si</span><br><span class="line">Remote connection closed</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>从0x10002a到0xf010002c这一条指令崩了，所以是通不过的，因为没有正确的设置映射。</p><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="#Formatted Printing to the Console"></a>#Formatted Printing to the Console</h4><p>大多数人认为printf()这样的函数是理所当然的，有时甚至认为它们是C语言的“基本类型”。<br>但是在操作系统内核中，我们必须自己实现所有的I/O。</p><p>通过阅读kern/printf.c, lib/printfmt.c,和kern/console.c，确保理解他们的关系。后面的实验室将会清楚为什么printfmt.c位于单独的lib目录中。</p><blockquote><p>练习8: 我们省略了一小段代码——使用“%o”形式的模式打印八进制数所需的代码。<br>查找并填充此代码片段。</p></blockquote><p>能够回答以下问题:</p><ol><li>解释printf.c和console.c之间的接口，特别是console.c暴露了什么函数？它又是怎么被printf.c使用的？</li><li><p>解释下面console.c中的代码:</p><pre><code>1      if (crt_pos &gt;= CRT_SIZE) {2              int i;3              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)5                      crt_buf[i] = 0x0700 | &apos; &apos;;6              crt_pos -= CRT_COLS;7      }</code></pre></li><li><p>对于下面的问题，你们可以参考第二讲的讲义。这些注释涵盖了GCC在x86上的调用约定。</p><p> 一步一步的跟踪执行下面代码:</p><pre><code>int x = 1, y = 3, z = 4;cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</code></pre><ul><li>在调用cprintf()时，fmt指向什么?ap指向什么?</li><li>列出(按执行顺序)对cons_putc、va_arg和vcprintf的每个调用。对于cons_putc，也列出它的参数。对于va_arg，列出调用前后ap指向的内容。对于vcprintf，列出它的两个参数的值。</li></ul></li><li><p>运行下面的代码:</p><pre><code>unsigned int i = 0x00646c72;cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</code></pre><p> 输出是什么?按照前面的练习一步一步地解释这个输出是如何得到的。这是一个ASCII表，它将字节映射到字符。</p><p> 输出取决于x86是little-endian这一事实。如果x86是big-endian，为了得到相同的输出，您会将i设置为什么?您是否需要将57616更改为不同的值?</p><p> 下面是对<a href="http://www.webopedia.com/TERM/b/big_endian.html" target="_blank" rel="noopener">小端和大端</a>以及<a href="http://www.networksorcery.com/enp/ien/ien137.txt" target="_blank" rel="noopener">更异想天开的描述</a>。</p></li><li><p>在下面的代码中，’y=’后面会打印什么?(注意:答案不是一个特定的值。)为什么会这样?</p><pre><code>cprintf(&quot;x=%d y=%d&quot;, 3);</code></pre></li><li><p>假设GCC更改了它的调用约定，以便按声明顺序在堆栈上推送参数，以便最后一个参数被推送到最后。您将如何更改cprintf或它的接口，使它仍然能够传递可变数量的参数?</p></li></ol><h4 id><a href="#" class="headerlink" title="#"></a>#</h4><h4 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h4><p>继续更新中…</p><h3 id="test😀"><a href="#test😀" class="headerlink" title="test😀"></a>test😀</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">test(<span class="keyword">void</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;课程-MIT-6-828-OS&quot;&gt;&lt;a href=&quot;#课程-MIT-6-828-OS&quot; class=&quot;headerlink&quot; title=&quot;课程 MIT 6.828 OS&quot;&gt;&lt;/a&gt;课程 MIT 6.828 OS&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;课程计划表地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很久以前尝试过学堂在线清华的os课程，Lab1、Lab2确实也存在一定难度😀。&lt;/p&gt;
&lt;h3 id=&quot;为什么记录&quot;&gt;&lt;a href=&quot;#为什么记录&quot; class=&quot;headerlink&quot; title=&quot;为什么记录&quot;&gt;&lt;/a&gt;为什么记录&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;方便自己严谨的看待每一句话，每一行代码，进行详细分析以及加深理解及记忆，而不是遇到困难直接快速跳过，尝试补齐欠缺知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不懂的时候以及理解不深刻的时候可以:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尝试梳理这里有什么前置知识&lt;/li&gt;
&lt;li&gt;记录查找前置知识的过程&lt;/li&gt;
&lt;li&gt;记录阅读了哪些前置知识&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随心及阅读轨迹思考轨迹记录，尽可能的还原学习路线，帮助自己理解及回顾，&lt;strong&gt;如果&lt;/strong&gt;能帮助到其他人就是更好的结果了，还有就是尽可能把Lecture读薄。&lt;/p&gt;
&lt;h1 id=&quot;Lab-1-Booting-a-PC&quot;&gt;&lt;a href=&quot;#Lab-1-Booting-a-PC&quot; class=&quot;headerlink&quot; title=&quot;Lab 1: Booting a PC&quot;&gt;&lt;/a&gt;Lab 1: Booting a PC&lt;/h1&gt;&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;专注3个部分，围绕三个目标学习更有效率：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉X86汇编、QEMU模拟器、PC加电启动程序&lt;/li&gt;
&lt;li&gt;测验boot文件夹中的bootloader&lt;/li&gt;
&lt;li&gt;深入研究kernel文件中kernel初始化模板&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="2019" scheme="https://blog.dxscx.com/tags/2019/"/>
    
      <category term="MIT" scheme="https://blog.dxscx.com/tags/MIT/"/>
    
      <category term="OS" scheme="https://blog.dxscx.com/tags/OS/"/>
    
      <category term="6828" scheme="https://blog.dxscx.com/tags/6828/"/>
    
      <category term="COURSE" scheme="https://blog.dxscx.com/tags/COURSE/"/>
    
  </entry>
  
  <entry>
    <title>默默的涨工资，这是一个惊喜，我对这件事心怀感恩</title>
    <link href="https://blog.dxscx.com/2017/02/13/mood/thanksgiving/"/>
    <id>https://blog.dxscx.com/2017/02/13/mood/thanksgiving/</id>
    <published>2017-02-12T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.317Z</updated>
    
    <content type="html"><![CDATA[<p>前几天收到了工资，咋一看多了许多，凡是我都会往好的方面去想，难道是公司给的奖励？作为实习生来说能收到奖励应该实属不易，准备过两天收到工资条明细看看怎么回事，如果发错了，应该退回去的。</p><a id="more"></a><p>收到工资条我第一时间给自己解密，打开工资条认真核对了一下各项，有两项格外让我注意，那就是调薪，基本工资。这两项明显变化了，原来领导给我调薪了，这就是多出那么多工资的原因，有点奇怪的是？为什么要给你涨工资没提前给你任何通知？也没有任何征兆，难道是我忽略了一些细节？不过很开心，这真是一个惊喜。</p><p>这个惊喜对于一个实习生来说是“强反馈”，不管自己有多累，付出了多少，有这种不是经过自己要求、“申讨”的方式的涨工资实属让人振奋，同时也很感谢我的直系领导，不仅仅是在工作上耐心指导和帮助（我希望我也没给您丢脸，哈哈），还暗中给我涨了不少工资，Nice上司，这是对小子的莫大肯定，太感谢！</p><p>这是一个惊喜，我对这件事心怀感恩！我会越来越好，我也会一如既往的给出“正反馈”，持续输出,加油加油。</p><p>原文地址: <a href="https://blog.dxscx.com/2017/02/13/mood/thanksgiving/">https://blog.dxscx.com/2017/02/13/mood/thanksgiving/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天收到了工资，咋一看多了许多，凡是我都会往好的方面去想，难道是公司给的奖励？作为实习生来说能收到奖励应该实属不易，准备过两天收到工资条明细看看怎么回事，如果发错了，应该退回去的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://blog.dxscx.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="2017" scheme="https://blog.dxscx.com/tags/2017/"/>
    
      <category term="mood" scheme="https://blog.dxscx.com/tags/mood/"/>
    
      <category term="new year" scheme="https://blog.dxscx.com/tags/new-year/"/>
    
      <category term="thanksgiving" scheme="https://blog.dxscx.com/tags/thanksgiving/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--图--Graph</title>
    <link href="https://blog.dxscx.com/2017/02/07/algorithm/fundamental/graph/graph/"/>
    <id>https://blog.dxscx.com/2017/02/07/algorithm/fundamental/graph/graph/</id>
    <published>2017-02-06T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>The Graph Process Pattern<br>The representation and implement of Graph was separated.We will create many implement about each kind of graph process algorithm.<br><a id="more"></a></p><h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>This implement edition was not include:</p><ol><li>add a vertex</li><li>delete a vertex</li><li>delete an edge</li><li>check v-w edge whether exist</li></ol><p>The reason that this edition did not implement the methods above:</p><ol><li>Usage case sometimes needn’t add and delete a vertex.</li><li>Simplify implement and more focus on Graph research process.</li></ol><p>More details:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/graph/Graph.java" target="_blank" rel="noopener">Graph.java</a></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><h4 id="DepthFirstSearch"><a href="#DepthFirstSearch" class="headerlink" title="DepthFirstSearch"></a>DepthFirstSearch</h4><p>main methods:</p><ol><li><p>public boolean marked(int v) {…}</p><p> Mark the vertex was visited.</p></li><li><p>public int count() {…}</p><p> The vertexes connected <code>s</code> total count.</p></li></ol><p>The key thinking is recursion. When you reach a vertex, mark it marked.And visit all connect with current vertex,<br>until visit all of those.</p><p>More details:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/graph/DepthFirstSearch.java" target="_blank" rel="noopener">DepthFirstSearch.java</a></p><h4 id="DepthFirstPaths"><a href="#DepthFirstPaths" class="headerlink" title="DepthFirstPaths"></a>DepthFirstPaths</h4><p>main methods:</p><ol><li><p>public boolean hasPathTo(int v) {…}</p><p> return the result that start vertex is reachable to the vertex <code>v</code></p></li><li><p>public Iterable<integer> pathTo(int v) {…}</integer></p><p> return one of the all paths that start vertex to the vertex <code>v</code></p></li></ol><p>The key thinking is that <code>DepthFirstPaths</code> hold an array called <code>edgeTo</code>.</p><p>The array to store the last vertex, e.g. if 0 can reach 2 by vertex 1 (0-&gt;1-&gt;2),then store 1 at edgeTo[2].</p><p>e.g.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paths:</span><br><span class="line">0-&gt;1</span><br><span class="line">1-&gt;6</span><br><span class="line">0-&gt;2</span><br><span class="line">2-&gt;3</span><br><span class="line">2-&gt;4</span><br><span class="line">4-&gt;5</span><br></pre></td></tr></table></figure></p><p>the graph to a tree reachable represent:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0</span><br><span class="line">1      2</span><br><span class="line">  6  3   4</span><br><span class="line">            5</span><br></pre></td></tr></table></figure></p><p>if use 0 as start vertex,the array of edgeTo data as follows；</p><p>edgeTo as follows:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index-&gt;last reachable vertex</span><br><span class="line">0-&gt;0</span><br><span class="line">1-&gt;0</span><br><span class="line">2-&gt;0</span><br><span class="line">3-&gt;2</span><br><span class="line">4-&gt;2</span><br><span class="line">5-&gt;4</span><br><span class="line">6-&gt;1</span><br></pre></td></tr></table></figure></p><p>so edgeTo—-&gt; {0,0,0,2,2,4,1}</p><p>More details:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/graph/DepthFirstPaths.java" target="_blank" rel="noopener">DepthFirstPaths.java</a></p><p>See more:<a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">Algorightm 4th plan</a></p><p>Origin Adress: <a href="https://blog.dxscx.com/2017/02/07/algorithm/fundamental/graph/graph/">https://blog.dxscx.com/2017/02/07/algorithm/fundamental/graph/graph/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The Graph Process Pattern&lt;br&gt;The representation and implement of Graph was separated.We will create many implement about each kind of graph process algorithm.&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="graph" scheme="https://blog.dxscx.com/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--红黑二分查找树--RedBlackBinarySearchTree</title>
    <link href="https://blog.dxscx.com/2017/02/03/algorithm/fundamental/tree/redblackbinarysearchtree/"/>
    <id>https://blog.dxscx.com/2017/02/03/algorithm/fundamental/tree/redblackbinarysearchtree/</id>
    <published>2017-02-02T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>The last article discussed the binary search tree, we know that the tree is unbalanced. The appearance is determined by the order in which the data are inserted.</p><p>Therefore, the <code>Red Black Binary Search Tree</code> appeared.<br>see source code:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/redblackbinarysearchtree/RedBlackBinarySearchTree.java" target="_blank" rel="noopener">RedBlackBinarySearchTree.java</a></p><a id="more"></a><p>If you want to know more about <code>Red Black Binary Search Tree</code>, I suggest you to know 2-3 tree first. Then you will understand RBTree more deeply.</p><h4 id="About-Rotate-Node-Rules"><a href="#About-Rotate-Node-Rules" class="headerlink" title="About Rotate Node Rules"></a>About Rotate Node Rules</h4><ol><li>if right subnode is red and left subnode is black,then execute left rotate</li><li>if left subnode is red and its left subnode also is red, then execute right rotate</li><li>if left subnode and right subnode both are red, the execute color flip. (current node’s color change to red,left subnode and right subnode’s color change to black)</li></ol><p>see source code:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/redblackbinarysearchtree/RedBlackBinarySearchTree.java" target="_blank" rel="noopener">RedBlackBinarySearchTree.java</a></p><p>See more:<a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">Algorightm 4th plan</a></p><p>Original Address: <a href="https://blog.dxscx.com/2017/02/03/algorithm/fundamental/tree/redblackbinarysearchtree/">https://blog.dxscx.com/2017/02/03/algorithm/fundamental/tree/redblackbinarysearchtree/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The last article discussed the binary search tree, we know that the tree is unbalanced. The appearance is determined by the order in which the data are inserted.&lt;/p&gt;
&lt;p&gt;Therefore, the &lt;code&gt;Red Black Binary Search Tree&lt;/code&gt; appeared.&lt;br&gt;see source code:&lt;a href=&quot;https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/redblackbinarysearchtree/RedBlackBinarySearchTree.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RedBlackBinarySearchTree.java&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="tree" scheme="https://blog.dxscx.com/tags/tree/"/>
    
      <category term="redblackbinarysearchtree" scheme="https://blog.dxscx.com/tags/redblackbinarysearchtree/"/>
    
      <category term="redblacktree" scheme="https://blog.dxscx.com/tags/redblacktree/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--二分查找树--BinarySearchTree</title>
    <link href="https://blog.dxscx.com/2017/01/31/algorithm/fundamental/tree/binarysearchtree/"/>
    <id>https://blog.dxscx.com/2017/01/31/algorithm/fundamental/tree/binarysearchtree/</id>
    <published>2017-01-30T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>As you know, <code>Binary Search</code> is a method to search data in a sorted array. <code>Binary Search Tree</code> is a search tree derived from the <code>Binary Search</code> thinking.</p><p>see source code:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/binarysearchtree/BinarySearchTree.java" target="_blank" rel="noopener">BinarySearchTree.java</a></p><a id="more"></a><h4 id="put-data-test"><a href="#put-data-test" class="headerlink" title="put data test"></a>put data test</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Put test.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinarySearchTree tree = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">    Integer[] integers = <span class="keyword">new</span> Integer[] &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">110</span>, <span class="number">80</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">120</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : integers) &#123;</span><br><span class="line">      tree.put(i, i + <span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  the tree preview as follow</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *           100</span></span><br><span class="line"><span class="comment">    *     90          110</span></span><br><span class="line"><span class="comment">    *  80    95    105   120</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//the output as follow</span></span><br><span class="line">    tree.print();<span class="comment">//80 90 95 100 105 110 120</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-min-node-test"><a href="#delete-min-node-test" class="headerlink" title="delete min node test"></a>delete min node test</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Delete min test.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMinTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BinarySearchTree tree = <span class="keyword">new</span> BinarySearchTree();</span><br><span class="line">    Integer[] integers = <span class="keyword">new</span> Integer[] &#123;<span class="number">100</span>, <span class="number">90</span>, <span class="number">110</span>, <span class="number">80</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">120</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : integers) &#123;</span><br><span class="line">      tree.put(i, i + <span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get the array list of the tree</span></span><br><span class="line">    List&lt;Node&gt; nodes = tree.toArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">      System.out.print(nodes.get(i).key + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete min node and assert it</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">0</span>).key, tree.deleteMin().key); <span class="comment">//80</span></span><br><span class="line">    <span class="comment">//delete min node and assert it</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">1</span>).key, tree.deleteMin().key); <span class="comment">//90</span></span><br><span class="line">    <span class="comment">//delete min node and assert it</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">2</span>).key, tree.deleteMin().key); <span class="comment">//95</span></span><br><span class="line">    <span class="comment">//delete min node and assert it</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">3</span>).key, tree.deleteMin().key); <span class="comment">//100</span></span><br><span class="line">    <span class="comment">//delete min node and assert it</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">4</span>).key, tree.deleteMin().key); <span class="comment">//105</span></span><br><span class="line">    <span class="comment">//assert min change to 105</span></span><br><span class="line">    Assert.assertEquals(nodes.get(<span class="number">5</span>).key, tree.min());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The binary search tree search and put efficiency depending on the order of data input.</p><h4 id="data-example-1-100-90-80-50-110"><a href="#data-example-1-100-90-80-50-110" class="headerlink" title="data example 1: 100 90 80 50 110"></a>data example 1: 100 90 80 50 110</h4><p>the tree will be this behaviour<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         100</span><br><span class="line">      90    110</span><br><span class="line">   80</span><br><span class="line">50</span><br></pre></td></tr></table></figure></p><h4 id="data-example-2-90-80-50-100-110"><a href="#data-example-2-90-80-50-100-110" class="headerlink" title="data example 2: 90 80 50 100 110"></a>data example 2: 90 80 50 100 110</h4><p>the tree will be this behaviour<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       90</span><br><span class="line">   80     100</span><br><span class="line">50            110</span><br></pre></td></tr></table></figure></p><p>The tree is not balanced and exist problems of efficiency about search and insert.</p><h4 id="simple-conclusion-about-BinarySearchTree-operation"><a href="#simple-conclusion-about-BinarySearchTree-operation" class="headerlink" title="simple conclusion about BinarySearchTree operation"></a>simple conclusion about BinarySearchTree operation</h4><blockquote><p>All conclusion you can compare with the <a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/binarysearchtree/BinarySearchTree.java" target="_blank" rel="noopener">source code</a> to view</p></blockquote><ul><li><strong>int size()</strong>: </li></ul><p>get node’s size via recursive method</p><ul><li><strong>Value get(Key key)</strong>: </li></ul><p>return the Value if key equal current node’s key; if key less than current node’s key find continue in the left subtree vice versa. </p><ul><li><strong>void put(Key key,Value value)</strong>: </li></ul><p>put from root node,if root node is null then create a new instance of node as root node. if the key greater than current node’s key, put it in left subtree vice versa.</p><ul><li><strong>Key max()</strong>:</li></ul><p>find current node’s right node until current node’s right node is null, now current node’s left node is null return current node otherwise return current node’s left nod.</p><ul><li><strong> Key min()</strong>:</li></ul><p>similar to max method but reverse. </p><ul><li><strong>Key floor(Key key)</strong>:</li></ul><p>this method indicate that return return the key that greater than or equal it, and it must be in the tree</p><p>if current node’s key equal then return current node’s key. if current node’s key greater than key find continue in the left subtree. They both are not true,then find in the right subtree.</p><ul><li><strong>Key ceiling(Key key)</strong>:</li></ul><p>similar to floor method but reverse. </p><ul><li><strong>Key select(int k)</strong>:</li></ul><p>This method to find the k-th node’s key.</p><p>The most important thinking come from this line code <code>select(node.right, k - size - 1);</code>. It can indicate the relationship about <code>k</code> with <code>size</code> clearly.</p><ul><li><strong>int rank(Key key)</strong>:</li></ul><p>This method to find the key’s rank in the tree.</p><p>similar to select method that the most important thinking is the code <code>1 + size(node.left) + rank(node.right, key);</code>, you should know the node’s size is node’s left subnode and right subnode’s size sum. But node’s right subnode is greater than current node, you need deal carefully.</p><ul><li><strong>void delete(Key key)</strong>:</li></ul><p>Delete method is the most important method in the <code>Binary Search Tree</code>. When you delete a node, you must deal the subnode carefully.<br>And whatever how to deal the node, the key point is that you must keep the order of the tree.<br>Generally, you will meet the few kinds situations as follow:</p><ol><li>current node don’t has any subnode<br>the most simple situation,just set its parent node relational pointer it to null and update relational node’s size.</li><li>current node has left subnode or right subnode only<br>set current node’s parent node relational pointer to current node’s left subnode or right subnode, then current node set to null and update relational node’s size.</li><li>current node has left subnode and right subnode<br>the key thinking is that set current node’s right subtree’s min node to current node and delete the min node, meanwhile remain the current node’s left node and update relational node’s size.</li></ol><p>and convert above thinking to recursion code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = delete(node.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.right = delete(node.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.right;</span><br><span class="line">      &#125;</span><br><span class="line">      Node temp = node;</span><br><span class="line">      node = min(temp.right);</span><br><span class="line">      node.right = deleteMin(temp.right);</span><br><span class="line">      node.left = temp.left;</span><br><span class="line">    &#125;</span><br><span class="line">    node.N = size(node.left) + size(node.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Node  deleteMin()</strong>:</li></ul><p>This method to delete min node. The key point is to find left subnode until it is null and delete it,meanwhile you need to set the node(left subnode is null) right subnode to the node’s parent node’s relational pointer.</p><ul><li><strong>Node  deleteMax()</strong>:</li></ul><p>This method similar to <code>deleteMin</code> that to delete max node.</p><ul><li><strong>Iterator<node> keys()</node></strong>:</li></ul><p>This method is to change the data to a iterator type data. In order to reduce process, I use <code>toArrayList().iterator()</code> in this method.</p><p>see source code:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/binarysearchtree/BinarySearchTree.java" target="_blank" rel="noopener">BinarySearchTree.java</a></p><p>See more:<a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">Algorightm 4th plan</a></p><p>Original Address: <a href="https://blog.dxscx.com/2017/01/31/algorithm/fundamental/tree/binarysearchtree/">https://blog.dxscx.com/2017/01/31/algorithm/fundamental/tree/binarysearchtree/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;As you know, &lt;code&gt;Binary Search&lt;/code&gt; is a method to search data in a sorted array. &lt;code&gt;Binary Search Tree&lt;/code&gt; is a search tree derived from the &lt;code&gt;Binary Search&lt;/code&gt; thinking.&lt;/p&gt;
&lt;p&gt;see source code:&lt;a href=&quot;https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/tree/binarysearchtree/BinarySearchTree.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BinarySearchTree.java&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="tree" scheme="https://blog.dxscx.com/tags/tree/"/>
    
      <category term="binarysearchtree" scheme="https://blog.dxscx.com/tags/binarysearchtree/"/>
    
  </entry>
  
  <entry>
    <title>【多图】境无好坏，唯有心造</title>
    <link href="https://blog.dxscx.com/2017/01/28/mood/your_heart/"/>
    <id>https://blog.dxscx.com/2017/01/28/mood/your_heart/</id>
    <published>2017-01-27T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.317Z</updated>
    
    <content type="html"><![CDATA[<p>今天过年不回家，年前早已计划好准备一个人过一个年试一试，因为我想尝试一下，也许只有一个人体验过才能更好的珍惜身边的人和事。一个人虽显有些孤独，不过也并不孤独，因为我能更好的去感知生活，感知这个真是存在的世界。当你能感受到真实的存在着，活着是多么好的时候，也就并不会感受到孤独。</p><a id="more"></a><h3 id="一个人的团年饭"><a href="#一个人的团年饭" class="headerlink" title="一个人的团年饭"></a>一个人的团年饭</h3><p>很开心前几天收到婆婆寄给我洗的腊肉，还带有几节香肠。说实话来北京快半年了，我也馋过，淘宝买了一回“四川自家熏制香肠”，算了吧，和婆婆做的香肠比起来真的不是一个档次的，只能说家里的太好吃了。</p><p>以往在家团年婆婆爷爷都会事先把腊肉什么的煮好，然后再经过切什么的，炒什么的就变成了桌上的美食了，这个过程我很后悔没有亲身经历过，我最多是帮忙传传柴火，前半年的我还能干些什么？我不知道。在我的记忆里我们家团年饭都是婆婆爷爷做的，爸爸妈妈很忙，三十天忙着生意只到快临近饭点才关上门坐上车回老家吃个团年饭。真的很喜欢婆婆爷爷做的饭菜，铁罐子做出来的饭，简直香。</p><p>今年过年我该怎么办？我收到了腊肉，收到了香肠，它们并不是熟食，需要我自己加工。用依稀的记忆照着婆婆的流程我也自己把肉“处理”了。我首先是煮的香肠，然后住的那个大大的腊肉，我开始以为我是没法处理这个腊肉的，挺大的，难得做。因为一个人，你想吃只能动手了。</p><p>模仿着婆婆以前切肉的样子，我把那个腊肉肥瘦分开，我不想吃肥的，我要把哪一块肥肥的用来炼“油仔儿”，我们这边就这么叫，把肥肉煎的酥酥的，又在收集起来后面炒菜用，真的挺香。这个腊肉真的挺大一块，可能是婆婆疼我，怕我不够吃给我选了一个大的。把腊肉处理完还是挺有成就感的，因为我居然能一个人能操刀想做们切就怎么切，还“游刃有余”，肥的肥，瘦的瘦，想怎么吃就怎么吃。</p><p>把肉处理完我就简单用剩饭做了点给自己吃，不想大块吃肉，至少当天晚上不想，所以我切成了一小块一小块放在了饭里。还加了一点东北产的“韩国泡菜”，这样搭配着还挺好吃的。</p><p><img src="https://sssvip.github.io/static/img/your_heart/tuannianfan.png" alt="your_heart.png"></p><h3 id="大年初一，出去走一走"><a href="#大年初一，出去走一走" class="headerlink" title="大年初一，出去走一走"></a>大年初一，出去走一走</h3><p>原计划假期就全部在家看几天书，然后敲敲代码实践一些算法的，到了三十的晚上想了想，大年初一，我决定还是出去走一走，哪怕短短的几个小时也好。</p><p>起床后，看见还是一如既往的“北京天”，是雾还是霾我从没认真的区分过，不过这个也许会影响心情。不过我想，还是必须要出去，就算吸他妹的霾也要出去走一走。</p><p>打开手机和一个很重要的人聊了天，就算雾霾，我也是带着很好的心情出去的。</p><p>一路上我并没有期待什么，因为我就是简单的出去走一走，这种感觉如果你有你就能体会到，是多么的怡然自得，多么的快乐。</p><p><img src="https://sssvip.github.io/static/img/your_heart/subway.png" alt="subway.png"></p><p>刚上地铁的时候就是这样的，在北京你周末都是看不到这个情形的，人烟稀少，不过越往城中心走渐渐多了起来，不过还是算稀少。</p><p><img src="https://sssvip.github.io/static/img/your_heart/tram.png" alt="tram.png"><br>因为没有什么期待，所以看见这个电车都能让我高兴好一阵子，来北京快半年了，我居然不知道还有电车，不经感叹朝阳区真大呀，哈哈。</p><p><img src="https://sssvip.github.io/static/img/your_heart/straight.png" alt="straight.png"><br>看到这种笔直的道路我都会很高兴，这也是我来北方的一个原因。</p><h3 id="闹中取静的东岳庙会"><a href="#闹中取静的东岳庙会" class="headerlink" title="闹中取静的东岳庙会"></a>闹中取静的东岳庙会</h3><p>为什么会选择东岳庙会？</p><p>因为目前住在通州区，百度地图搜索了一下“庙会”，看这个“东岳”挺不错，最近不说，点评也不错。毫不犹豫就选择了它。</p><p>北京东岳庙位于北京市朝阳区朝阳门外大街的北侧，原是道教正一道在中国华北地区的第一大丛林。第一感觉是这个闹中取静的城中小庙是很不错的。简单拍了一个全景图。<br><img src="https://sssvip.github.io/static/img/your_heart/panoramic.png" alt="panoramic.png"></p><p>也许你已经看到了，左边是东岳庙，正中央就是百脑汇，右边蓝色的是沃尔玛，右边还有苏宁易购什么的，真的算是闹中取静了，取得一份悠闲。</p><h3 id="庙会体验一：训白鼠"><a href="#庙会体验一：训白鼠" class="headerlink" title="庙会体验一：训白鼠"></a>庙会体验一：训白鼠</h3><p><img src="https://sssvip.github.io/static/img/your_heart/train_mouse.png" alt="train_mouse.png"></p><p>这是我看进入东岳庙的第一个“把戏”，训白鼠，很普通，没能带能什么感觉。</p><h3 id="庙会体验二：木偶戏"><a href="#庙会体验二：木偶戏" class="headerlink" title="庙会体验二：木偶戏"></a>庙会体验二：木偶戏</h3><p><img src="https://sssvip.github.io/static/img/your_heart/puppet.png" alt="puppet.png"></p><p>这是第一个让我开心的笑的木偶戏，也许没怎么看过木偶戏，这里还有点小故事。</p><p>表演的是放羊的小孩打死老虎的戏，过程很短，表演者的声音模仿还是有几分有趣，途中让我都笑了好几次，是真心的笑，不是简单的认为它搞笑，这也是为什么有了后来的行为的原因。</p><p>表演完后就像正常“套路一样”，出来“收钱”啦。我条件反射似的转身就走，感觉怕把我抓到要钱的一样。没走两步我后悔了，我觉得我该付费的，因为我开心了，是很久没有的那种发自内心的开心，我就在内心自责，也许我不该转身的，也许如果我掏出了一点零钱，会有更多人掏出零钱的，就像现在的付费阅读，付费学习一样，有一种为其付费的冲动。出于不好意思我没走几步就到了旁边的一个“圣旨”展厅转，我千想万想还是应该对他表示一种肯定，我有“灰溜溜”似的回到了这里。</p><p>掏出零钱以表示肯定，我觉得应该给其“正反馈”，民间艺术应该得到尊重，还没走到表演者跟前，他似乎看出来我的来意，他就开口说了一句“没关系的”，顺手接下了我的“肯定”，不多，我觉得我是对的，我快乐了，我愿意付费，并且他应该得到“反馈”。</p><p>但他的“没关系的”是什么意思？这个值得思考，难道不是吗？难道他经常遇到这种事情？经常遇到观众跑了，还回来“给予肯定”？我思考了良久。</p><h3 id="庙会体验三：扔铜钱"><a href="#庙会体验三：扔铜钱" class="headerlink" title="庙会体验三：扔铜钱"></a>庙会体验三：扔铜钱</h3><p><img src="https://sssvip.github.io/static/img/your_heart/coin_01.png" alt="coin_01.png"><br><img src="https://sssvip.github.io/static/img/your_heart/coin_02.png" alt="coin_02.png"></p><p>这个还是挺有意思的，仍一种看似金币的东西去砸那个钟，“钟响即福”，这也是一个很有意思的游戏，钟声真的好听，很想和你分享它的声音。</p><p>飞快的逛完了它，它确实也不大，为什么全文中逛庙会没有一点和庙会相关的东西？为什么不是说一些道教相关的？我并没有，我真的不是来烧香拜佛的，我真的是简单的逛一逛，感受庙会气氛，感受过年的气氛的。</p><p>不过很喜欢庙会里香火的味道，说不出来为什么，也许是仅仅喜欢这个味道，也许是喜欢香火旺的人流，也许是喜欢这个感觉。</p><p>一个城中小庙，没有来错。</p><h3 id="只要你想，太阳会一只跟着你"><a href="#只要你想，太阳会一只跟着你" class="headerlink" title="只要你想，太阳会一只跟着你"></a>只要你想，太阳会一只跟着你</h3><p><img src="https://sssvip.github.io/static/img/your_heart/sun.png" alt="sun.png"></p><p>左边两张是到达庙会附近拍的，那个时候太阳刚刚出来，心情正好太阳也出来了，真的是想什么来什么。</p><p>右边是两张返程的时候拍的。太阳真的跟着我在走。</p><p>真的是境无好坏，唯有心造，快乐的一天又过去了。</p><p>原文地址: <a href="https://blog.dxscx.com/2017/01/28/mood/your_heart/">https://blog.dxscx.com/2017/01/28/mood/your_heart/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天过年不回家，年前早已计划好准备一个人过一个年试一试，因为我想尝试一下，也许只有一个人体验过才能更好的珍惜身边的人和事。一个人虽显有些孤独，不过也并不孤独，因为我能更好的去感知生活，感知这个真是存在的世界。当你能感受到真实的存在着，活着是多么好的时候，也就并不会感受到孤独。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://blog.dxscx.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="2017" scheme="https://blog.dxscx.com/tags/2017/"/>
    
      <category term="mood" scheme="https://blog.dxscx.com/tags/mood/"/>
    
      <category term="new year" scheme="https://blog.dxscx.com/tags/new-year/"/>
    
  </entry>
  
  <entry>
    <title>人生的选择-换一种心态继续生活</title>
    <link href="https://blog.dxscx.com/2017/01/24/mood/the_choice_of_life/"/>
    <id>https://blog.dxscx.com/2017/01/24/mood/the_choice_of_life/</id>
    <published>2017-01-23T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.317Z</updated>
    
    <content type="html"><![CDATA[<p>为什么突然用中文写了？因为前面的全英文博文是我的一种尝试，也许尽管里面很多语法错误，甚至很多单词错误，希望不要误导到别人，我在尝试尽可能的表达清楚以及减少失误。因为我认为用英文书写这是一个必经过程，必须要给自己营造全英文环境的过程，不是说有好崇洋媚外，不是说有好喜欢英语，而是英语是在获取知识、更加好的认识这个世界一个比较好的一种语言，就像中文地位一样。英语对于之前的我来说，虽然知道英语重要，真的是没有太多兴趣的，也没用到实处，显而易见的是英语也很差，到今年16年9月开始后来不断阅读更多的全英文文档和国外的全英文教程、视频（所以非常感谢实习公司迷你校，及CTO均哥，还有Udacity的学习），是他们让我逐渐对英语有了浓厚的兴趣，也认识到非常有学习的必要，在过程中培养了一点点语感，尝试在这一方面也提升自己，后面我还是会继续尝试用全英文写的。</p><a id="more"></a><p>人生其实有很多选择的，为什么突然要写这么一篇文章呢？主要是前几十分钟的信息浏览感触颇多，有必要写一写东西。</p><p>每次受到阅读的文章，书籍，或者人物的影响后感触是颇多的，但是真正要写些东西给自己的时候又难以起笔。所以每次写东西之前都喜欢给自己规划一下这篇文章的大概逻辑线，以免自己写着写着忘了些东西，规划一下大致的章节或者说如何更好的分段，这次我将这样划分：</p><ul><li>关于市场竞争力和心存焦虑、惶恐</li><li>对于知识的态度</li><li>对于人生的态度</li><li>又一个小小的规划</li></ul><h4 id="关于市场竞争力和心存焦虑、惶恐"><a href="#关于市场竞争力和心存焦虑、惶恐" class="headerlink" title="关于市场竞争力和心存焦虑、惶恐"></a>关于市场竞争力和心存焦虑、惶恐</h4><p>从15年10月真正认认真真开始学习软件相关技术以来，让我算是真正了解到了一种坚持，一种坚持学习的过程和感觉，这一年多时间确实感谢自己学习到了很多知识，在学校或在实习公司中自己也没有因后来者的角色处于太过于明显的“劣势”。反倒是要不是自己的一些“小聪明”或者是休息时间的继续专研让自己看起来在某些技术应用走在周围同龄人前，或者说不仅仅是能够应用，理解更加到位一些。这可能，仅仅是可能就造就了在某些技术点上自己能有更多话语权，或者说话底气更足的“幻觉”。</p><p>我从没有因有这种“幻觉”而侥幸，而是“逼迫”自己更努力，每天必定坚持学习很久，上班如果没空余时间就下班后，很多时候是阅读到深夜2点，周末也没给自己规划去哪去哪玩，不是实践某些代码，就是宅在家里阅读，然后自己给自己做点简单又美味的饭犒劳自己。这样做一是维持能让自己在某种技术点或者面上说话更有底气，而是提升自己所谓的竞争力。</p><p>就算自己这样，一天一天的学习工作中相关的技术，或者现在完全用不到的但以后肯定有用的技术，但这样看似“按部就班”的学习会让自己感到很安心吗？在如此浮躁的年代里(并不是所有人，大多数吧)，难免会怀疑自己，怀疑自己的学习方向，怀疑自己学的知识真的有用吗？以后这会成为自己竞争力中的一个必不可少的部分吗？</p><p>如果认真分析为什么就算你在不断学习，不断进步的同时都还会如此的浮躁，如此的学习的很不安心，如此的怀疑自己。归根接地的原因在于：</p><ol><li><strong> 你清楚的知道你学习的东西仅仅是表面知识</strong><br>也许只是在给自己堆砌“技能树”，在开始学习的初始阶段这确实能让我很开行，我好“NB”呀，居然会这么多东西技术，让我做一个网站我怎么可能做不出来。但当你的工程化，行业化越来越浓的时候不仅仅是在语法糖，语言上逗留，提升自己的途径还必须是计算机领域这么多年积淀的东西，还是需要自己慢慢啃一些你觉得有必要的计算机基础，那才能巩固自己的知识“地基”，而不是在一直简单使用某种语言特性，某种语法糖带给你的快感。</li><li><strong>随着深度的的深度加深越来越觉得自己太无知</strong><br>想刚入门的时候会觉得自己好”NB”呀，感觉自己什么都会一样，感觉学习什么都很简单一样，感觉学习什么都会来的那么快，这些真的是很无知的。让你高效解决业务数据还是大量数据的情况下，你开始认识到必须好好设计一番数据存储，设计一番如何高效就行查改，这些不是简单入门知识就能轻松容易的设计出符合要求的方案的。很多是需要数学知识和计算机基础知识去做辅助的，而不是靠简单的几层思考逻辑就能解决，还是建立在很多理论基础上来，如果你对这些引用的理论熟悉或者能加以修改改进，那该是多么应用自如。这也是在逐步加深自己的知识的过程中认识到的，自己知道的太少了，太无知。</li><li><strong>也许在一心想着速成</strong><br>都想在有限的时间内快速提高自己，让自己看着收获，只要迫切想快速让自己收获学习成效，控制不好力度也许就会慢慢演变成浮躁。在这个到处充斥着“XX分钟入门”，“XX分钟搞定”，“XX小时精通”快餐式的文化影响，很多人都被潜移默化的影响着，学习很多东西专注度不高，稍有困难就像转战“新领域”，或者认为精通了，而不是潜心研究，潜心提高知己。想在某个段时间区间内，达到自己想要却又无法快速达到的效果，这也会让自己怀疑自己能力，知识获取的过程本来就是循序渐进的，不是一蹴而就的。这也是自己认识到自己的问题，这也会导致心存焦虑，惶恐。</li><li><strong>你存在选择疑虑</strong><br>比如现在AI比较火，也许就会假设在未来10年AI会占据着大部分市场，那么对于一个目前仍然学习传统算法，传统编程的人会不会是站错队？是不是应该放弃现在的，全心投入比较火的领域？我想不是的，仔细分析下那些AI前沿的人的学习过程，他们不是一蹴而就的，我仍然坚信应该好好巩固自己的基础知识，很多东西你没有，你必须潜心学习，而不是浮躁的去涉猎即可，要相信坚持下来，终究你是能做你想要的。<h4 id="对于知识的态度"><a href="#对于知识的态度" class="headerlink" title="对于知识的态度"></a>对于知识的态度</h4></li></ol><p>对知识的态度一定要有这种超脱：</p><blockquote><p>“大家在求学期间不要把将来求得温饱这件事情当作自己生活的唯一目标，各位都是在中国最顶尖的人才，我希望大家把理想放得高一些，要做一个有用的人，要做大事业，成为一个顶天立地的人！” </p></blockquote><p>这段话来自57岁时回国的姚期智先生，可以搜索了解下这个伟人。其实不仅仅是求学期间，就算是工作中也一样，稍微改变一下对知识的态度，在解决问题的时候至少不会全部一贯“蜻蜓点水”一样解决问题后点到为止，而是会思考这个还该不该认真理解一番，该不该深入了解。</p><p>认真反思自己，难道现在所做出的所谓提高自己“竞争力”，所谓的学习，不都是为了求的温饱吗？认真思考是不是，也许为了提升见识，也许为了提升能力，归根结底都会转化为升职加薪（不绝对），或者为了让自己更好的创造以谋取收入到实现财富自由。</p><p>这样的学习会是痛苦的，这样的学习会是想快速提高回报率的，这样的学习也许不是最好的学习方式。为何不换一种获取知识的态度，以前真的没认识到这一点，改变一种获取知识的态度也许能让你更好的获取知识以及解决问题。</p><p>我以前也许无法理解一个超过30+的人还需要攻读硕士，超过30+的人还要故意折腾自己，明明可以在某个工作岗位上“踏踏实实”的工作下去的，并且是高薪的。这个人就是“冰河”，真名“田春”，有兴趣可以搜索，我是故意不放链接的，就如上文的姚期智博士相关资料一样，我阅读了很多。提高这个兴趣门槛，有兴趣的自己会搜索的。</p><p>“冰河”2005年本科毕业于浙江大学，2006-2010期间在网易工作，并且干的有声有色，这样的背景下，如果对于普通的追求很多都是能轻易满足的，为什么34+还要去读硕士？为何到了30多岁还要折腾也许他本科就能接触或者学习过的知识？这是对知识的何等渴望，也许背后又一个更大的愿景支撑着他。</p><p>昨晚看《与外婆同行》被女主一句很多人看似不起眼的一句话触动：“为什么很多人可以学业和家庭兼顾，而我却不能”，这句话不仅仅是表现这个女主个体，更能表现整个美国社会，为什么会说出这句话，那是因为美国这个社会很多人就算有了家庭都会继续自己的求学之路，回看中国社会，这种例子有，但是不多。</p><p>整个社会都变成了就算有了家庭都会存在继续求学，都会继续研究，提高整个社会的生产力，而不是为了疲于应付工作而学习的琐碎知识，而这显然不是核心竞争力。</p><h4 id="对于人生的态度"><a href="#对于人生的态度" class="headerlink" title="对于人生的态度"></a>对于人生的态度</h4><p>人生确实短暂，如果简简单单追求物质生活就是<code>“赚钱-&gt;买房-&gt;买车-&gt;结婚-&gt;儿子买房-&gt;儿子买车-&gt;儿子结婚-&gt;儿子的儿子买房...”</code>，虽然过程中有很多不一样，也许物质生活几个大节点就是这样，一眼看到头的生活，了无生趣。确实不应该仅仅追求物质生活，一个阶段一个阶段满足自己的物质欲望。我很羡慕“冰河”先生的胆大，超凡脱俗。他被称为“伞哥”，这个原因我就不在这说了。</p><p>很喜欢一句话“用心去感受这个世界”，人生如此短暂不应该仅仅为了所谓的生活质量（物质类）去疲于应付，疲于去应付一个有一个“节点”。</p><p>大胆的去做一些你认为值得也许对你物质生活帮助不大，或者不明显的事情吧，其实说到底，这些会反过来帮助你提升物质生活的，比过这种态度会影响你在提升你的物质生活。</p><p>这里值得说的是不反对提升物质生活，我也想提升我的物质生活呀，只是说它不是全部，不要被其蒙蔽就好。</p><h4 id="又一个小小的规划"><a href="#又一个小小的规划" class="headerlink" title="又一个小小的规划"></a>又一个小小的规划</h4><ul><li><strong> 加强英语的学习</strong> </li></ul><p>虽然现在常听英语散文，刚听的时候只知道朗读者在说英语，现在我真的不费力，更加顺畅的听清楚了他的含义，这是让我很高兴的，这种有效反馈能让我学习的更有效，有点绕。</p><p>英语至少在目前来说是获取顶尖科技最好的语言,中文虽然好，但在这一块人群的差异（不是指中国人和他们差异，而是走在前沿的或者某种技术前沿都采用英文来表达， 表现），所以坚持学习好好学习它。</p><p>继续多用全英文环境去书写博文，提升自己，为下一步做铺垫。</p><ul><li><strong> 出国深造求学</strong> </li></ul><p>真正的求学，获取知识，认识人类文明的历史，认识这个世界。虽然不是现在，你知道的，不是那么容易，不想给家里增加任何负担，但是我想这是我人生中必有的一步。</p><h4 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h4><p>写到最后也许就变成了废话，但今天主要感谢“冰河”对我的影响，这也许印证了“皮裤效应”，人们相信他们相信的，对这就是我相信的，也是我一直以来坚信的。</p><p>虽然活了二十二年，很多时候都会想前二十一年我都干了什么？不过如果再重新活22年，也许现在还是一样，不后悔自己走过的路，现在真的不晚。我以前一直觉得自己生命不长，真的不骗人，我感觉自己日子不多了一样，但现在并不会这么认为了，未来的路很长，很长，戒骄戒躁认真的感受这个世界！</p><p>原文地址: <a href="https://blog.dxscx.com/2017/01/24/mood/the_choice_of_life/">https://blog.dxscx.com/2017/01/24/mood/the_choice_of_life/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么突然用中文写了？因为前面的全英文博文是我的一种尝试，也许尽管里面很多语法错误，甚至很多单词错误，希望不要误导到别人，我在尝试尽可能的表达清楚以及减少失误。因为我认为用英文书写这是一个必经过程，必须要给自己营造全英文环境的过程，不是说有好崇洋媚外，不是说有好喜欢英语，而是英语是在获取知识、更加好的认识这个世界一个比较好的一种语言，就像中文地位一样。英语对于之前的我来说，虽然知道英语重要，真的是没有太多兴趣的，也没用到实处，显而易见的是英语也很差，到今年16年9月开始后来不断阅读更多的全英文文档和国外的全英文教程、视频（所以非常感谢实习公司迷你校，及CTO均哥，还有Udacity的学习），是他们让我逐渐对英语有了浓厚的兴趣，也认识到非常有学习的必要，在过程中培养了一点点语感，尝试在这一方面也提升自己，后面我还是会继续尝试用全英文写的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://blog.dxscx.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="mood" scheme="https://blog.dxscx.com/tags/mood/"/>
    
      <category term="learn" scheme="https://blog.dxscx.com/tags/learn/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--排序--Sortable抽象类</title>
    <link href="https://blog.dxscx.com/2017/01/22/algorithm/fundamental/sort/sortable/"/>
    <id>https://blog.dxscx.com/2017/01/22/algorithm/fundamental/sort/sortable/</id>
    <published>2017-01-21T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>There is no surprise,reading progress faster than implement. Now,I was reading the section 2.5 in algorithm 4th.But I am just start plan to implement the sort part.I very like a saying:”slower is faster”. So just do yourself better.</p><a id="more"></a><div id="google_translate_element"></div><h4 id="why-to-define-an-abstract-class-called-Sortable"><a href="#why-to-define-an-abstract-class-called-Sortable" class="headerlink" title="why to define an abstract class called Sortable?"></a>why to define an abstract class called <code>Sortable</code>?</h4><ol><li><p>Extract the common code part of sort,reduce code repeat</p></li><li><p>More specifically to implement a kind of sort,not mess</p></li></ol><p>This is a good method to implement sort. Because I don’t mess more,I just divide implement to more step. I just focus per step how to implement,not here and there meanwhile.</p><p>As sort, it can be divide into two necessary steps that compare and exchange.</p><h4 id="why-to-define-an-abstract-class-called-Sortable-1"><a href="#why-to-define-an-abstract-class-called-Sortable-1" class="headerlink" title="why to define an abstract class called Sortable?"></a>why to define an abstract class called Sortable?</h4><p>I try to define an interface not an abstract class,then I found that not a good practice.</p><p>Although define a Sortable interface can ensure the subclass must implement each method.If I implement the sortable interface, I must to implement the each method in <code>QucikSort</code>,<code>MergeSort</code>,<code>SelectSort</code>,etc. But think it seriously,not need implement each method in a specific Sort Class. Many method just common code for many specific Sort Class.</p><p>So I remember it can use abstract class to define,if not specific method, just use default implement. If some method not common code,it must to implement specific,it can declare an abstract method.Then in specific Sort Class implement it specifically.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The abstract class Sortable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line"><span class="comment">//compare</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">...omission some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//exchage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">...omission some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print to show</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">...omission some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check sorted</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">...omission some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort from 0 to a.length</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">...omission some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//specific sort class implement specifically</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check index offset</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkOffset</span><span class="params">(Comparable[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Two-most-important-methods-in-Sortable-Class"><a href="#Two-most-important-methods-in-Sortable-Class" class="headerlink" title="Two most important methods in Sortable Class"></a>Two most important methods in Sortable Class</h4><ol><li><p>less method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * compare value of v and w,if v less than w return true, vice versa</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v the v</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the w</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>exch method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * exchange index of i,j 's data of array a</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j the j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  Comparable t = a[i];</span><br><span class="line">  a[i] = a[j];</span><br><span class="line">  a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>see source code:<a href="https://github.com/sssvip/algorithms4th/blob/master/src/fundamentals/sort/common/Sortable.java" target="_blank" rel="noopener">Sortable.java</a></p><p>See more:<a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">Algorightm 4th plan</a></p><p>Original Address: <a href="https://blog.dxscx.com/2017/01/22/algorithm/fundamental/sort/sortable/">https://blog.dxscx.com/2017/01/22/algorithm/fundamental/sort/sortable/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is no surprise,reading progress faster than implement. Now,I was reading the section 2.5 in algorithm 4th.But I am just start plan to implement the sort part.I very like a saying:”slower is faster”. So just do yourself better.&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="sort" scheme="https://blog.dxscx.com/tags/sort/"/>
    
      <category term="sortable" scheme="https://blog.dxscx.com/tags/sortable/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--一步一步实现List接口--MiniArrayList的index方法测试并改进代码</title>
    <link href="https://blog.dxscx.com/2017/01/18/algorithm/fundamental/list/arraylist/MiniArrayList-indexTest/"/>
    <id>https://blog.dxscx.com/2017/01/18/algorithm/fundamental/list/arraylist/MiniArrayList-indexTest/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>MiniArrayList是实现List接口，初步实现，未考虑太多，简化初步学习的噪音，预期达到最后和ArrayList的效果，当然性能最后也会测试对比，希望用这种方式来提高自己。（此部分全部代码见：<a href="https://github.com/sssvip/algorithms4th/tree/master/src/fundamentals/list" target="_blank" rel="noopener">https://github.com/sssvip</a>）</p><p>接上一篇博文，<a href="https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/">https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/</a></p><a id="more"></a><div id="google_translate_element"></div><h3 id="4-indexTest"><a href="#4-indexTest" class="headerlink" title="4. indexTest"></a>4. indexTest</h3><p> reference API: </p><ul><li>MiniArrayList()  –constitution method</li><li>indexOf(Object o) –return the index of Object in List,return -1 if not exist</li><li>lastIndexOf(Object o)  –return the last index of Object in List,return -1 if not exist</li><li>clear() –clear the data of List</li><li>isEmpty() –return true if List have data,vice versa </li></ul><h4 id="a-indexTest"><a href="#a-indexTest" class="headerlink" title="a. indexTest()"></a>a. indexTest()</h4><p>first check the code from repository.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout MiniArrayList_indexTest</span><br></pre></td></tr></table></figure><p>Then in the MiniArrayListCompareTest.java you will find a indexTest method. code as follow:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MiniArrayList&lt;String&gt; miniArrayList = <span class="keyword">new</span> MiniArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      miniArrayList.add(<span class="string">"indexTest"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    miniArrayList.add(<span class="string">"indexTest"</span> + <span class="number">2</span>);</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      arrayList.add(<span class="string">"indexTest"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    arrayList.add(<span class="string">"indexTest"</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//test print index direct</span></span><br><span class="line">    System.out.println(miniArrayList.indexOf(<span class="string">"indexTest1"</span>));<span class="comment">//1</span></span><br><span class="line">    System.out.println(arrayList.indexOf(<span class="string">"indexTest1"</span>));<span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print object last index</span></span><br><span class="line">    System.out.println(miniArrayList.lastIndexOf(<span class="string">"indexTest2"</span>));<span class="comment">//NullPointerException </span></span><br><span class="line">    System.out.println(arrayList.lastIndexOf(<span class="string">"indexTest2"</span>));<span class="comment">//5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print isEmpty</span></span><br><span class="line">    System.out.println(miniArrayList.isEmpty());<span class="comment">//false</span></span><br><span class="line">    System.out.println(arrayList.isEmpty());<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test clear and print isEmpty again</span></span><br><span class="line">    miniArrayList.clear();</span><br><span class="line">    arrayList.clear();</span><br><span class="line">    System.out.println(miniArrayList.isEmpty());<span class="comment">//true</span></span><br><span class="line">    System.out.println(arrayList.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run the code you will find a Exception:</p><p>the code <code>miniArrayList.lastIndexOf(&quot;indexTest2&quot;)</code> will throw NullPointerException,more detail about this issue see this repository issue #4,so I will Fix it.</p><h4 id="b-fix-indexTest-reference-issue"><a href="#b-fix-indexTest-reference-issue" class="headerlink" title="b. fix indexTest() reference issue"></a>b. fix indexTest() reference issue</h4><p>Fortunately,this time just a one issue.</p><ul><li><p><strong>issue list:</strong><br>MiniArrayList lastIndexOf() NullPointerException</p></li><li><p><strong>issue detail:</strong><br>MiniArrayList lastIndexOf() in for cycle had an incorrect usage that control the value of i</p></li><li><p><strong>how to solve the issues:?</strong> </p><p>  Open the lastIndexOf method source code will find the error easy.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; <span class="number">0</span>; i++) &#123;  <span class="comment">//--&gt; for (int i = size-1; i &gt;= 0; i--)</span></span><br><span class="line">      <span class="keyword">if</span> (data[i].equals(o)) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  This is clearly mistake to control the value of i. why it will throw NullPointerExcption? Just because first enter for cycle,data[size] just a null value,it should be data[size-1].As we know,null value to invoke equals method will throw NullPointerException.</p><p>  So fix it via <code>for (int i = size-1; i &gt;= 0; i--)</code></p></li></ul><h4 id="c-indexTest-Run-again"><a href="#c-indexTest-Run-again" class="headerlink" title="c. indexTest() Run again"></a>c. indexTest() Run again</h4><p>checkout the modified code use the command as follows:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check out MiniArrayList_indexTest_fixed</span><br></pre></td></tr></table></figure></p><p>run indexTest method in MiniArrayListCompareTest again,you will find the output will consistent with ArrayList’s. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">indexTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MiniArrayList&lt;String&gt; miniArrayList = <span class="keyword">new</span> MiniArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      miniArrayList.add(<span class="string">"indexTest"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    miniArrayList.add(<span class="string">"indexTest"</span> + <span class="number">2</span>);</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      arrayList.add(<span class="string">"indexTest"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    arrayList.add(<span class="string">"indexTest"</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//test print index direct</span></span><br><span class="line">    System.out.println(miniArrayList.indexOf(<span class="string">"indexTest1"</span>));<span class="comment">//1</span></span><br><span class="line">    System.out.println(arrayList.indexOf(<span class="string">"indexTest1"</span>));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//test print object last index</span></span><br><span class="line">    System.out.println(miniArrayList.lastIndexOf(<span class="string">"indexTest2"</span>));<span class="comment">//5</span></span><br><span class="line">    System.out.println(arrayList.lastIndexOf(<span class="string">"indexTest2"</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//test print isEmpty</span></span><br><span class="line">    System.out.println(miniArrayList.isEmpty());<span class="comment">//false</span></span><br><span class="line">    System.out.println(arrayList.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//test clear and print isEmpty again</span></span><br><span class="line">    miniArrayList.clear();</span><br><span class="line">    arrayList.clear();</span><br><span class="line">    System.out.println(miniArrayList.isEmpty());<span class="comment">//true</span></span><br><span class="line">    System.out.println(arrayList.isEmpty());<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="d-Conclusion-about-indexTest"><a href="#d-Conclusion-about-indexTest" class="headerlink" title="d. Conclusion about indexTest()"></a>d. Conclusion about indexTest()</h4><p>Although just a little mistake about to control the value of i in the for cycle,but it can show the careless when code.<br>More careful,more careful.</p><p>After fix issue #4,then you can see:<a href="https://github.com/sssvip/algorithms4th/tree/MiniArrayList_indexTest_fixed" target="_blank" rel="noopener">MiniArrayList_indexTest_fixed</a></p><p>更多参见: <a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">算法4系列计划</a></p><p>原文地址: <a href="https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-indexTest/">https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-indexTest/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MiniArrayList是实现List接口，初步实现，未考虑太多，简化初步学习的噪音，预期达到最后和ArrayList的效果，当然性能最后也会测试对比，希望用这种方式来提高自己。（此部分全部代码见：&lt;a href=&quot;https://github.com/sssvip/algorithms4th/tree/master/src/fundamentals/list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sssvip&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;接上一篇博文，&lt;a href=&quot;https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/&quot;&gt;https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="List" scheme="https://blog.dxscx.com/tags/List/"/>
    
      <category term="ArrayList" scheme="https://blog.dxscx.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>算法4一起来--一步一步实现List接口--MiniArrayList的add方法测试并改进代码</title>
    <link href="https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/"/>
    <id>https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/</id>
    <published>2017-01-16T16:00:00.000Z</published>
    <updated>2019-09-23T09:42:08.313Z</updated>
    
    <content type="html"><![CDATA[<p>MiniArrayList是实现List接口，初步实现，未考虑太多，简化初步学习的噪音，预期达到最后和ArrayList的效果，当然性能最后也会测试对比，希望用这种方式来提高自己。（此部分全部代码见：<a href="https://github.com/sssvip/algorithms4th/tree/master/src/fundamentals/list" target="_blank" rel="noopener">https://github.com/sssvip</a>）</p><p>接上一篇博文，<a href="https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList/">https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList/</a></p><a id="more"></a><div id="google_translate_element"></div><h3 id="3-addTest"><a href="#3-addTest" class="headerlink" title="3. addTest"></a>3. addTest</h3><p>reference API: </p><ul><li>MiniArrayList()  –constitution method</li><li>add(T t) –add data</li><li>toArray()  –output data as array</li><li>toString() –output data as String</li></ul><h4 id="a-addTest-添加方法对比小测"><a href="#a-addTest-添加方法对比小测" class="headerlink" title="a. addTest() 添加方法对比小测"></a>a. addTest() 添加方法对比小测</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MiniArrayList&lt;String&gt; miniArrayList = <span class="keyword">new</span> MiniArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      miniArrayList.add(<span class="string">"test"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      arrayList.add(<span class="string">"test"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test print size</span></span><br><span class="line">    System.out.println(miniArrayList.size());<span class="comment">//stackoverflow before fix #1</span></span><br><span class="line">    System.out.println(arrayList.size());<span class="comment">//5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print out direct</span></span><br><span class="line">    System.out.println(miniArrayList);<span class="comment">//fundamentals.list.MiniArrayList@1376c05c  see issue #2</span></span><br><span class="line">    System.out.println(arrayList);<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print out by array</span></span><br><span class="line">    System.out.println(Arrays.toString(miniArrayList.toArray()));<span class="comment">//[test0, test1, test2, test3, test4, null, null, null, null, null] see issue #3</span></span><br><span class="line">    System.out.println(Arrays.toString(arrayList.toArray()));<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="b-fix-addTest-reference-issue-修复addTest方法中涉及的问题"><a href="#b-fix-addTest-reference-issue-修复addTest方法中涉及的问题" class="headerlink" title="b. fix addTest() reference issue 修复addTest方法中涉及的问题"></a>b. fix addTest() reference issue 修复addTest方法中涉及的问题</h4><p><strong>issue list:</strong></p><ul><li>issue #1: MiniArrayList size() stackoverflow</li><li>issue #2: MiniArrayList print out direct just the memery address not the data</li><li>issue #3: MiniArrayList print out by array will output the null value</li></ul><p><strong>issue detail:</strong></p><ul><li>issue #1 detail: MiniArrayList’s size method incorrect recursion lead to stackoverflow error.</li><li>issue #2 detail: System.out.println(MiniArrayList’s instance) will output the memory address not similar to ArrayList just output the data.</li><li>issue #3 detail: System.out.println(Arrays.toString(miniArrayList.toArray())) will output the null value but ArrayList not.</li></ul><p>more issue detail see: <a href="https://github.com/sssvip/algorithms4th/issues" target="_blank" rel="noopener">https://github.com/sssvip/algorithms4th/issues</a></p><p><strong>how to solve the issues:?</strong></p><ul><li><p>issue #1: <strong>solve incorrect recursion</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size(); --&gt; <span class="keyword">return</span> <span class="keyword">this</span>.size; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>issue #2: <strong>thinking and solving process</strong></p><ol><li>I guess it must to override the toString method.</li><li><p>I find the ArrayList class’s toString to see its toString()</p><blockquote><p>but ArrayList don’t have any toString shadow… Then I guess it must extend from his super class.I see toString in his super<br>  class AbstractList,AbstractCollection etc. I found the method in the AbstractCollection class.</p></blockquote><p> AbstractCollection class’s toString() code as follows:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        E e = it.next();</span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Analyze this situation I add toString method in MiniArrayList,code as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">      stringBuilder.append(data[i].toString());</span><br><span class="line">      <span class="keyword">if</span> (i != <span class="keyword">this</span>.size - <span class="number">1</span>) &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">','</span>).append(<span class="string">' '</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringBuilder.append(<span class="string">"]"</span>).toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>issue #3: <strong>thinking and solving process</strong></p><ol><li>Now MiniArrayList toArray() will return the all of Object[],it include null space</li><li>I must to see ArrayList class’s toArray(),I guess it must handled the data array.</li><li>After see ArrayList class’s toArray(),That’s a surprise,oh my god,I didn’t think I should copy the value data to user,I just return the Object[].</li><li><p>Let’s see the code of ArrayList class’s toArray():</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>So I update MiniArrayList toArray() as follows:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">   <span class="keyword">return</span> data; --&gt;Arrays.copyOf(data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="c-addTest-Run-again"><a href="#c-addTest-Run-again" class="headerlink" title="c. addTest() Run again"></a>c. addTest() Run again</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MiniArrayList&lt;String&gt; miniArrayList = <span class="keyword">new</span> MiniArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      miniArrayList.add(<span class="string">"test"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataSize; i++) &#123;</span><br><span class="line">      arrayList.add(<span class="string">"test"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test print size</span></span><br><span class="line">    System.out.println(miniArrayList.size());<span class="comment">//5</span></span><br><span class="line">    System.out.println(arrayList.size());<span class="comment">//5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print out direct</span></span><br><span class="line">    System.out.println(miniArrayList);<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">    System.out.println(arrayList);<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//test print out by array</span></span><br><span class="line">    System.out.println(Arrays.toString(miniArrayList.toArray()));<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">    System.out.println(Arrays.toString(arrayList.toArray()));<span class="comment">//[test0, test1, test2, test3, test4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see, in addTest() MiniArrayList’s output is consistent with ArrayList.</p><h4 id="d-Conclusion-about-addTest"><a href="#d-Conclusion-about-addTest" class="headerlink" title="d. Conclusion about addTest()"></a>d. Conclusion about addTest()</h4><ul><li><p>forget use System.copyOf() reference API,if it suit you situation, you should use JDK’S API first,not implement again.</p><p>reason as follows:</p><ol><li>the JDK’s API through thousands of people check,error rate lower than your implement.</li><li>your implement maybe not consider many you didn’t consider situation,such as the arguments null.</li></ol></li><li><p>about the this.size() issue,this is a mistake,so you know the knowledge maybe you will code error.</p></li><li>Maybe use many times ArrayList,but just know a little knowledge about ArrayList,so should see the source code more and more.</li></ul><p>After fix issue #1,#2,#3,then you can see:<a href="https://github.com/sssvip/algorithms4th/tree/MiniArrayList_V0.2" target="_blank" rel="noopener">MiniArrayList_V0.2</a></p><p>更多参见: <a href="https://blog.dxscx.com/2017/01/12/algorithm/plan/">算法4系列计划</a></p><p>原文地址: <a href="https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/">https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList-addTest/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MiniArrayList是实现List接口，初步实现，未考虑太多，简化初步学习的噪音，预期达到最后和ArrayList的效果，当然性能最后也会测试对比，希望用这种方式来提高自己。（此部分全部代码见：&lt;a href=&quot;https://github.com/sssvip/algorithms4th/tree/master/src/fundamentals/list&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sssvip&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;接上一篇博文，&lt;a href=&quot;https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList/&quot;&gt;https://blog.dxscx.com/2017/01/17/algorithm/fundamental/list/arraylist/MiniArrayList/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://blog.dxscx.com/tags/java/"/>
    
      <category term="algorithm" scheme="https://blog.dxscx.com/tags/algorithm/"/>
    
      <category term="algorithm 4" scheme="https://blog.dxscx.com/tags/algorithm-4/"/>
    
      <category term="plan" scheme="https://blog.dxscx.com/tags/plan/"/>
    
      <category term="data structure" scheme="https://blog.dxscx.com/tags/data-structure/"/>
    
      <category term="List" scheme="https://blog.dxscx.com/tags/List/"/>
    
      <category term="ArrayList" scheme="https://blog.dxscx.com/tags/ArrayList/"/>
    
  </entry>
  
</feed>
